redis
https://www.cnblogs.com/jasonZh/p/9513948.html
## 数据类型

1.字符串
    1.Java对象通过ObjectMapper等JOSN解析框架进行序列化与反序列化，从而将对象转化为JSON格式的字符串
        或者将序列化后得字符串反序列化解析为对象
        二进制安全 可以储存jpg图像或者序列化字符串
    2.场景：
        统计微博点赞数 粉丝数

2.列表
    1.一个列表对应一个key 按照插入顺序排序 可以选择插入头部或者尾部 可以操作中间某一段
    2.实现方式为双向链表
    3.Redis列表使用于“排名”、“排行榜”、“近期访问数据列表”
    4.取出N个最新的数据操作
        //把当前登录人添加到链表里
        ret = r.lpush("login:last_login_times", uid)
        //保持链表只有N位
        ret = redis.ltrim("login:last_login_times", 0, N-1)
        //获得前N个最新登陆的用户Id列表
        last_login_list = r.lrange("login:last_login_times", 0, N-1)
    5.可以作为消息队列系统

3.集合
    1.一个集合对应一个key 是string类型的集合
    2.hashtable实现
    3.Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。
    4.在微博中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis还为集合提供了求交集、并集、差集等操作，可以非常方便的实现如共同关注、共同喜好、二度好友等功能，对上面的所有集合操作，你还可以使用不同的命令选择将结果返回给客户端还是存集到一个新的集合中。
    5.
        会剔除重复的数据
        解决重复提交、剔除重复ID
    6.命令
        set 建集合
        sadd 
        sinter(a,b) 求ab两个集合的并集
        sdiff(a,b) 求差集 在a中且不再b中
        sunion(a,b)求并集

4.有序集合 zset
    1.包含了列表和集合的特性 每个string对应一个score来排序
    2.命令 zadd key score member
    3.场景：
        比如一个存储全班同学成绩的Sorted Set，其集合value可以是同学的学号，而score就可以是其考试得分，这样在数据插入集合的时候，就已经进行了天然的排序。另外还可以用Sorted Set来做带权重的队列，比如普通消息的score为1，重要消息的score为2，然后工作线程可以选择按score的倒序来获取工作任务。让重要的任务优先执行。

5.hash
    1.<key,value>  value是filed-value对 <key,<filed-value>>
    2.如存储一个用户对象 key为用户id filed为用户的各种属性 value为属性值
    3.使用hset 和hget命令来设置
    4.场景：存储部分变更数据，如用户信息等


## 判断Key失效
    1.set方法中设置时间
    2.redistemplate.expire()方法 设置失效时间
    3.使用场景：
        1.将数据库查询到的数据缓存一定的时间TTL，在该时间内
        前端查询访问数据列表时，只需要在缓存中查询
        2.将数据压入缓存队列，并设置一定的TTL时间，时间一到，
        触发监听事件，处理相应的业务逻辑

## 缓存出现的问题
    1.缓存穿透    
        1.问题描述
        当前端查询数据库中没有的key时，数据库查询到的永远是null，而
        null不会存入缓存，所以每次访问都会查数据库。流量大时，会压垮
        数据库。
        2.解决方案：
            当数据库中返回null时，将null塞入缓存，并对对应的key设置
            一定过期时间。
    2.缓存雪崩
        1.问题描述 在某个时间节点，缓存中的key集体发生过期失效致使大量查询、
        数据库的请求落在DB上
        2.解决：给key设置随机的TTL
    
    3.缓存击穿
        1.指缓存中某个频繁被访问的key（热点key）突然过期，导致一瞬间DB压力暴增
        2.设置该key长时间不过期

## 缓存一致性
    1.如何保证缓存与数据库的双写一致性？

        Cache Aside Pattern

        1.读的时候，先读缓存，缓存没有的话，那么就读数据库，然后取出数据后放入缓存，同时返回响应

        2.更新的时候，先删除缓存，然后再更新数据库

    2.为什么是删除缓存，而不是更新缓存？

        因为有可能查出来的数据不是通过指定字段进行查询出来的简单的数据，而是有多个表进行多个计算出来的复杂数据。

    3.数据库与缓存双写不一致问题？

        1 最初级的缓存不一致问题以及解决方案？

            问题：先修改数据库，在删除缓存，如果删除缓存失败了，那么会导致数据库中数据是新数据，缓存中是修改前的旧数据，数据出现不一致。

            解决思路：先删除缓存在删除数据库，如果修改数据库失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会导致不一致，因为读的时候缓存没有。则读数据库中是旧数据，然后更新到缓存中。

        2 比较复杂的数据不一致问题分析

            数据发生了变更，先删除了缓存，然后要去修改数据库，此时还没有修改，一个请求过来，去读缓存，发现缓存空了，去读数据库，查到了修改前的旧数据，放到了缓存中，数据变更的程序中完成了数据库的修改。

            此时数据库和缓存中数据就不一致了。。

        总结:读请求和写请求串行化，串到一个内存队列中。

    4.为什么上亿流程高并发场景下，缓存会出现这个问题呢？
        只有在对一个数据在高并发的情况下进行读写的时候，才可能出现这种问题。


## 分布式锁
    
    1.利用redis的原子性 实现分布式锁

    2.比如注册 用name当key  用uuid生成随机数作为value  线程a进来 把key和value存入了redis 线程b如果注册的name和a一样 那key也一样 setifabsent 方法会返回0 用一个if判断 为1的话才能继续注册  这样就巧妙的用redis实现了锁 最后操作完后都要在finally块中释放锁(当value和get(key)得到的value相等时才移除key 避免被别的线程移除)

## 持久化 
    1.RDB 对Redis中的数据执行周期性的持久化
       RDB 在保存 RDB 文件时父进程唯一需要做的就是 fork 出一个子进程,接下来的工作全部由子进程来做，父进程不需要再做其他 IO 操作，所以 RDB 持久化方式可以最大化 Redis 的性能。
    2.AOF 将每条写命令作为日志，以append-only模式写入一个日志文件，在Redis重启时，通过回放日志中的写入指令来重构整个数据
    3.RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储。
        1.AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾.Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大。
        2.如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式。
        3.你也可以同时开启两种持久化方式, 在这种情况下, 当redis重启的时候会优先载入AOF文件来恢复原始的数据,因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。
