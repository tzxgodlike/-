redis
## 数据类型

1.字符串
    Java对象通过ObjectMapper等JOSN解析框架进行序列化与反序列化，从而将对象转化为JSON格式的字符串
    或者将序列化后得字符串反序列化解析为对象

2.列表
    一个列表对应一个key
    Redis列表使用于“排名”、“排行榜”、“近期访问数据列表”

3.集合
    一个集合对应一个key
    会剔除重复的数据
    解决重复提交、剔除重复ID

4.有序集合
    包含了列表和集合的特性

5.hash
    <key,value>  value是filed-value对


## 判断Key失效
    1.set方法中设置时间
    2.redistemplate.expire()方法 设置失效时间
    3.使用场景：
        1.将数据库查询到的数据缓存一定的时间TTL，在该时间内
        前端查询访问数据列表时，只需要在缓存中查询
        2.将数据压入缓存队列，并设置一定的TTL时间，时间一到，
        触发监听事件，处理相应的业务逻辑

## 缓存出现的问题
    1.缓存穿透    
        1.问题描述
        当前端查询数据库中没有的key时，数据库查询到的永远是null，而
        null不会存入缓存，所以每次访问都会查数据库。流量大时，会压垮
        数据库。
        2.解决方案：
            当数据库中返回null时，将null塞入缓存，并对对应的key设置
            一定过期时间。
    2.缓存雪崩
        1.问题描述 在某个时间节点，缓存中的key集体发生过期失效致使大量查询、
        数据库的请求落在DB上
        2.解决：给key设置随机的TTL
    
    3.缓存击穿
        1.指缓存中某个频繁被访问的key（热点key）突然过期，导致一瞬间DB压力暴增
        2.设置该key长时间不过气

## 分布式锁
    
    1.利用redis的原子性 实现分布式锁

    2.比如注册 用name当key  用uuid生成随机数作为value  线程a进来 把key和value存入了redis 线程b如果注册的name和a一样 那key也一样 setifabsent 方法会返回0 用一个if判断 为1的话才能继续注册  这样就巧妙的用redis实现了锁 最后操作完后都要在finally块中释放锁(当value和get(key)得到的value相等时才移除key 避免被别的线程移除)

