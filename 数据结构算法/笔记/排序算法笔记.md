static修饰的方法可以直接调用



# **时间复杂度**
-------
     时间复杂度是衡量算法好坏的重要指标之一。时间复杂度反映的是不确定性样本量的增长对于算法操作所需时间的影响程度，与算法操作是否涉及到样本量以及涉及了几次直接相关，如遍历数组时时间复杂度为数组长度n（对应时间复杂度为O(n)）， 而对数据的元操作（如加减乘除与或非等）、逻辑操作（如if判断）等都属于常数时间内的操作（对应时间复杂度O(1)）。

     在化简某算法时间复杂度表达式时需遵循以下规则：

        1. 对于同一样本量，可省去低阶次数项，仅保留高阶次数项，如O(n^2)+O(n)可化简为O(n^2)，O(n)+O(1)可化简为O      (n)
        2. 可省去样本量前的常量系数，如O(2n)可化简为O(n)，O(8)可化简为O(1)
        3. 对于不同的不确定性样本量，不能按照上述两个规则进行化简，要根据实际样本量的大小分析表达式增量。如O(logm)    +O       (n^2)不能化简为O(n^2)或O(logm)。而要视m、n两者之间的差距来化简，比如m>>n时可以化简为O(logm)，因为表达式增量是由样本量决定的

    * 题目1：有序数组A，无序数组B，打印B中所有不在A的数，A数组长度为N，B数组长度为M。
    * 题目2：某种排序算法， 现在0-(n-1)范围上找最小值放0，再在1-(n-1)找最小值放1上，时间
    复杂度为n+n-1+n-2+....+1 为O(n^2)

    * 评价算法，先看时间复杂度指标 再看样本量 题目1三种方法可知

# **额外空间复杂度**
----------------------------------------------------------------------------
    算法额外空间复杂度指的是对于输入样本，经过算法操作需要的额外空间。比如使用冒泡排序对一个数组排序，期间只需要一个临时变量temp，那么该算法的额外空间复杂度为O(1)。又如归并排序，在排序过程中需要创建一个与样本数组相同大小的辅助数组，尽管在排序过后该数组被销毁，但该算法的额外空间复杂度为1O(n)1。

# **冒泡排序** O(n^2)
# **选择排序** O(n^2)
    和冒泡排序一样 每次确定一个位置的值
# **插入排序** 一般用最差数据情况
    遍历到第i个位置 把它与[0,i-1]进行遍历比较放入合适的位置
    -时间复杂度：
        1.有序时，比较N次 O(n)
        2.无序时，O(n^2)
# **对数器的概念和使用**# 代码在bubbleSort中
    1.有一个想测的方法A
    2.实现一个正确但是复杂度不好的方法B
    3.实现一个随机样本产生器 样本长度小点
    4.实现对结果对比的方法
    5.如果有一个样本使得对比出错 打印样本分析是哪个方法出错
    6.样本数量很多时，比对测试已然正确，则确定A已经正确
    PS：笔试之前准备数组随机样本发生器，二叉树样本发生器 堆准备模板

# **递归复杂度分析**
    -跑子过程之前父过程把当前函数的所有信息压到栈中，直到递归结束，再逐层返回
    -复杂度通式 T(N) = aT(n/b)+O(n^d) n/b子过程的样本量 a是子过程的数量 O是Tn内部剩下的时间复杂度
        子过程规模一样
        1.如果log(b,a)>d 复杂度为O(n^log(b,a))
        2.如果log(b,a)=d 复杂度为O(n^d*logn)
        3.如果log(b,a)<d 复杂度为O(n^d) 

# **归并排序分析** [重点掌握] 分治 递归 merge过程
    - 时间复杂度O(n*logn) 额外空间复杂度O(n)
    - 一个数组，左右分别排好序，然后创建一个辅助数组B 依次从左右数组首端开始比较 小的放入B中 然后后移 一个数组移到末尾之后 直接将另一数组放入B
    - T(n) = 2T(n/2)+O(n)  即时间复杂度为O(n*logn)   
    - 分治思想
    - mid = (l+r)/2会溢出 ，mid = l+(r-l)/2 不会溢出

    * 小和问题：一个数组中每一个左边比当前数小的数累加起来，叫做这个数组的小和。
        - 可以用归并排序，找到每一个数a的右边有多少(n)个数比它大，a*n累加
        - 精髓在于：在merge的过程中求小和，这样已有小数组中比a大的不会重复算，新的大数组中比a大的不会漏算，而且新数组中已经排好序，遍历时有一个比a大，后面的都比a大
    * 逆序对问题：一个数组中左边的数如果比右边的大，则两个数构成一个逆序对，请打印所有的逆序对
        - PrintCountInversions



# **快速排序** [重点掌握] 分治 递归  partition过程

问题:给定一个数组，一个数num，把小于等于num放左边，大于num的数放在数组右边，要求额外空间复杂度O(1)，时间复杂度O(n)
    - 数组左边为小于等于num区域A,p指向A区域末尾，q指向B区域第一个，如果q大于num，后移，如果小于等于，则与A区域的下一位交换，A区域扩大一位即p后移
问题:[荷兰国旗问题]给定一个数组，一个数num，把小于等于num放左边，等于num的数放在中间，大于num的数放在数组右边，要求额外空间复杂度O(1)，时间复杂度O(n)
    - 在数组左边划分小于区less，右边大于区more，cur指向第一个数 有点像分快递
        如果cur = num,cur++
        如果cur < num,该数和less区的后一个数交换位置，less++,cur++
        如果cur > num,该数和more区的前一个数交换位置，more--,cur不变!

    快排：

    - 排序L到R之间的数，选择任意数n，将小于该数的放左边，大于该数的放右边，n在中间
    然后递归排序L到n之间的数和n到R之间的数，直到区间缩小为1 中间n不参与递归
    - 改进： 
            1.参考荷兰国旗问题，选取原数组最后一个数作为n，返回等于n区域的起止坐标值来划分新区域
            2.当数据有序时，选最后一个数做n，复杂度会退化为O(n^2)
            3.所以每次选取数组中一个随机数来做划分 时间复杂度为O(n*logn)  
    - *随机快排最为常用* 额外空间O(logn) 即用来存储等于n区域的p数组消耗的空间  时间复杂度常数项系数也低 

# **堆排序**  [重点掌握] 一颗完全二叉树(上一层是满二叉树 最后一层从左到右依次补齐)
    - i结点左孩子2i+1 右孩子2i+2 父节点(i-1)/2
    - 大根堆：任何一颗子树的最大值都是这颗子树的头部
             
    - 加入新节点调整的复杂度只与树的高度有关 为O(logn) 所以建立二叉树的过程为log1+log2+...+logn = O(n)
    1.建堆
        时间复杂为O(n) 
        从下而上： 加入的结点与父节点比较，比父大就交换   heapinsert
    2.排序
        时间复杂度O(nlogn)
        把数组第一个元素与最后一个元素交换 在把剩下n-1个元素堆化heapify
        heapify 先比较子节点，与大的子节点交换 O(n)
    3.是原地排序 不稳定
    4.与快速排序的比较
        1.快速排序是顺序访问，对CPU缓存友好
        2.堆排序交换次数多与快速排序
    - 先构建大根堆(自下而上)，然后排序，把堆顶元素删除放到数组末尾，把末尾放到堆顶重新构建大根堆(自上而下)

    *动态数据利用堆求中位数：构建一个大根堆一个小根堆，新加入的数据加入一个堆，如果两堆个数差大于1，就把多的堆顶删除并加入另一个堆。这样某一个堆的堆顶就是中位数
        进阶：求99%响应时间  把堆的大小设为99:1
    *优先级队列 Java中PriorityQueue 
        1.合并有序小文件 
            有100个小文件，每个100M。存储都是有序的字符串，合并一个有序的大文件。
            思路1：每个小文件拿一个元素，放进数组中比较，把最小的弹出队伍。
            其实这个问题并不需要对100个元素在数组中排序，只需要知道其中最小的那个
            就行了。所以用数组要遍历整个数组O(n)，浪费时间
            思路2
                把100个元素放到小顶堆中，弹出堆顶，循环这个过程。
                删除堆顶和插入数据都是O(logn)
    *求topk
        1.静态数据 在一个N数据中的数组中查找前K大的数据。
            维护一个K大小的小顶堆 在顺序遍历数组 O(klogn)
        2.动态数据
            已有一个K的小顶堆 添加数据时，直接与堆顶比较，可以实时返回

    * 10亿个搜索关键词的日志文件 获取top10关键词
        先哈希表，求每个关键词的次数，在建立一个大小10的堆，遍历哈希表
        为了节省空间：
            先把10亿个文件分片到10个文件中 求出每个文件的top10 再把10个top10
            放在一起，求top10

# **排序稳定性**
---------------------
    - 排序之后相同值得相对顺序不变
    - O(n)
        - 冒泡排序、插入排序可以实现为稳定的
        - 选择排序是不稳定排序
    -O(logn)
        - 归并排序可以实现稳定性(相等时先拷贝左边)
        - 快速排序一般不能做到稳定性
        - 堆排序不能做到稳定性(建堆时就会被破坏)

# **工程上排序算法**
    - 如果数组装的基础类型(int double...)，会使用快排 不考虑稳定性
    - 如果数组装的自定义类型(student) 归并排序 要考虑稳定性
    - 如果数组长度很短(小于60)，使用插入排序(常数项极低) 此时n^2的劣势不明显 ,

# **排序问题补充**
    1. 归并排序额外空间可以变为O(1) 很难 不需要掌握 “内部缓存法” 
    2. 快速排序可以做到稳定性 很难 不需要掌握 “01 stable sort”
    3. 有一道题目是奇数放在数组左边，偶数放在数组右边没，并要求原始的相对顺序不变，要求空间O(1)时间O(n)可以怼面试官。

# **比较器的使用** 可以放入基于比较的排序结构中 如PriorityQueue(用堆实现) treemap(红黑树实现)
    返回负数，第一个参数放前面 返回整数则相反 下面为升序
    ......
    @Override
        public int compare(Student o1, Student o2) {
            return o1.id - o2.id;
        }
    ......
    优先级队列 也可以用比较器来排序
            PriorityQueue<Student> heap = new PriorityQueue<>(new IdAscendingComparator());

------------------------------------------------------------------------------------------------------------

*不是基于比较的排序*
# **桶排序**
    - 把数据放到有序的桶中，每个桶里的数据在单独进行排序，桶内排完之后，再把每个桶里的数据按顺序取出。
    - 计数排序是桶排序的特殊情况，K个数分到K个桶，类似于高考分数的一分一段表
    - 适用于外部排序 即10GB的数据需要在几百M的内存中进行排序
        1.先把大文件分成100个小文件 把每个小文件读入内存排序好
        2.再合并有序小文件(堆排序)

# **排序问题补充**
    - MaxGap
    - 给定一个数组，求如果排序后相邻两数的最大差值，要求时间复杂度O(n) 且要求不能用非基于比较的排序
    - 解法：有N个数，建造N+1个桶 先遍历原数组求最小值(放入第一个桶)和最大值(放入第N+1个桶) 每个桶的大小范围一样
   
    - 空桶的作用*并不是*说明差值最大的两个数是空桶左边的最大值和右边的最小值（该值可能为1个桶的长度，而相邻两个桶长度就有2桶长）！！！
        所以桶的意义在于保证所求的两个数必不在同一个桶内（因为最大差值必大于一个桶的长度） 
    - 每个桶只记录三个值：bool min max  不需要记录每个桶具体包含的值
        boolean hasNum[] = new boolean[len+1];
        int[] mins = new int[len+1];
        int[] maxs = new int[len+1];
    - 从一号桶开始 如果是空的，跳到下一个桶。如果非空，找左边最近的非空桶的最大值和自己最小值算差值 差值为全局变量
--------------------------------------------------
    问题1：用数组结构实现大小固定的队列和栈
        - 栈较简单 用index来判断边界
        - 队列复杂 需要循环利用这个数组 要用front和rear来定义首尾 当size没满rear已到数组末尾时，加一个数进来，rear会移到数组开头 所以需要定义一个size来让rear和front解耦(size定义边界) 
--------------------------------------------------
    问题2：实现一个特殊的栈，在实现栈的基本功能上，再实现返回栈中最小元素的操作
    要求：pop,push,getmin操作的时间复杂度都是O(1) 设计的栈类型可以使用现成的栈结构
        - 遍历求最小值的话 复杂度就是O(n)
    解法：定义两个栈，一个data栈，一个min栈 入栈时，如果该数大于min栈顶，则min栈重复压入栈顶，若小于等于栈顶，则压入该数。出栈同步弹出。Min栈顶就是最小元素。
--------------------------------------------------
    问题3：如何仅用队列结构实现栈结构?如何仅用栈结构实现队列结构?
    - 推广：图的深度遍历需要栈结构，如何使用队列实现深度遍历?------先用两个队列实现栈，然后再实现深度遍历。
    - 队列实现栈：使用两个栈，一个data,一个help。数据只进data栈，pop时，只要data.size大于1，就出队，再进help队，留下队尾的数弹出。然后把data和help栈的引用交换。
    - 栈实现队列：使用两个队列，一个push一个pop。数据全放入push栈，pop时把push栈的数据全倒入pop栈，然后弹出栈顶。倒的时候有两个原则：
        1.push栈的数据要一次性倒完 2.pop栈有数据时不能倒入。 一次出栈之后，把pop栈的元素放回push栈里面
---------------------------------------------------
    问题4：实现一种猫狗队列的结构，要求如下：用户可以调用add方法将cat类或dog类的实例放入队列中，用户调用pollAll()方法，将队列中所有实例按照进队列的先后顺序依次弹出；用户调用pollDog()方法，将队列中的dog类的实例按照进队列的先后顺序一次弹出；用户可以调用pollCat方法，将队列中cat类的实例按照进队列的先后顺序一次弹出，用户调用isEmpty方法，检查队列中是否还有dog或cat实例；用户调用isDogEmpty方法，检查队列中是否有dog类的实例；用户调用isDogEmpty方法，检查队列中是否有cat类实例。
    - 解法：设计两个队列 一个dog，一个cat。然后用一个类来封装猫和狗，里面设置一个变量count来标识该pet是第几个。该类需要有一个getEnterPetType方法来得到当前是狗还是猫，一个getPet方法来返回当前对象的类型，一个getCount来表明当前对象的计数。
      pollAll方法的话，直接比较两个队列队首的count，小的弹出，直到两个队列都弹完。
--------------------------------------------------
    问题5：转圈打印矩阵 [记住思想]
    - 解法：这个过程可以想象为每次打印一个矩阵的外框 然后把左上角和右下角的点往内圈移一圈，继续打印内框。
    - 搞清楚四个循环
-------------------------------------------------
    问题6: 顺时针90度旋转正方形矩阵 RotateMatrix [思想同上]
    - 解法：也是一圈一圈来打印 一次只旋转四个点(第一次是顶点) 要找好边界
--------------------------------------------------
    问题7：之字形打印矩阵 要求空间复杂度O(1)  
    - 解法：设定两个点AB，同时移动一格，A向右走，到最右时向下，B向下走，到最下时向右。每走一格，以AB为顶点画对角线，直到AB重合。之字形的轨迹就是这些对角线，设计一个打印对角线的函数。设置一个bool类型来判断打印对角线的顺序是从左到右还是右到左。
---------------------------------------------------
    问题8：给定一个N*M的整形矩阵matrix和一个整数K，matrix的每一行和每一列都是排好序的。实现一个函数，判断K是否在matrix中。要求时间复杂度为O(N+M),额外空间复杂度为O(1)
    - 解法：遍历的话时间复杂度不符合要求  从右上角开始向左依次比较 遇到小于K的向下依次比较 遇到大于K的再向左
            或者从左下角开始比较
---------------------------------------------------
    问题9：给定两个有序链表的头指针head1和head2，打印两个有序链表的公共部分。
    - 解法：有点像归并排序的merge过程。两个指针遍历，相等就打印，小的那个指针往后遍历。
--------------------------------------------------
    问题10：判断一个链表是否为回文结构 [笔试面试中要求解法不一样] [IsPalindromeList]
    - 解法: 笔试中：尽快过掉，可以使用辅助空间。
                1.把链表进栈，然后出栈与原链表对比，值全一样则true
                2.快慢指针 只把后半部分压栈再对比
                3.先把链表放入数组list中  再头尾双指针比较
            面试中：和面试官聊可以找最优解，额外空间达到O(1)[进阶]
                快指针走两步，慢指针走一步。快指针走到终点时，把后半指针逆序，然后一头一尾开始遍历比较。最后再把逆序的换回来。
                要点：1.如何链表逆序 2. n1=n2 是相当于移动n1 这里容易出错
-------------------------------
    问题11：将单向链表按某值划分为左边小、中间相等、右边大的形式
    - 解法： 笔试快速解法：链表放数组中，然后按荷兰国旗做，再变成链表。
    - 进阶要求：时间复杂度O(n) 空间复杂度O(1) 而且每部分的节点顺序要与原节点顺序一致 
    * 和面试官聊的时候要让他知道你了解稳定性，荷兰国旗问题等，然后引出最佳解法。
    - 最佳解法：新建三个Node,分别为less,equal.more 先遍历一遍链表 让less等于第一个小于num的结点，equal等于第一个为num的结点，more为第一个大于num的结点。然后在遍历链表。[看coding技巧] 
-----------------------------------------
    问题13：复制含有随机指针节点的链表 
        Node类中，除next指针外新增rand指针，该指针可能指向链表中任意一个节点，也可能指向null。实现一个函数完成这个链表中所有结构的复制，并返回复制的新链表的头节点。
        - 解法：需要使用哈希表(增删改查都是常数时间)。这题本质上是让你重建一个链表的节点关系，先遍历用一个哈希表把1节点和1'节点对应存起来， 再遍历一次来构造原节点关系。(先创建节点，再构建节点关系)
            需要额外空间O(n)
        - 进阶要求：不使用额外的数据结构，只用有限几个变量。并在O(n)时间复杂度完成原问题要实现的函数。
        - 最佳解法：原链表 1->2->3->null 新链表1->1'->2->2'->3->3'->null 遍历链表来设置rand 然后分开两个链表
-------------------------------------------
    问题14：单链表相交的一系列问题 比较节点时不是比较值而是内存地址
        单链表可能有环可能无环,实现一个函数，如果两个链表相交，请返回相交的第一个节点，如果不相交，返回null即可。要求：如果链表1长度为N，链表2的长度为M，时间复杂度请达到O(N+M)，额外空间复杂度请达到O(1)
        思路：将该问题分解为
            1.如何判断链表有环
                链表有环的话，里面的节点是不会指向null的
            2.如何判断无环单链表相交节点
            3.如何找到有环单链表相交节点
        解法：
            1.实现一个函数，无环则返回空，有环则返回第一个入环的节点；
                方法1.使用hashset，每遍历一个点就把该点加入到hashset中去
                方法2.两个指针，一个快一个慢，快指针一次两步，慢指针一次一步，若快指针指null,则没环
                      当快指针和慢指针相遇时，快指针回到开头，然后快指针变为走一步，快指针和慢指针一
                      定会在入环节点处相遇。  [这是一个结论]

            2.单链表若相交，只可能是Y字形，不会是X字形 判断相交并找到第一个相交的点
                方法1.遍历head1放入hashmap，遍历head2,每次都查询是否在map中出现过
                方法2.遍历head1和head2，得到相应的lenth和最后一个节点end1和end2。先判断end1是否和end2
                "相等"(内存地址一样)，若不等则不相交。长链表先走，等到长的剩下部分和短链表相等时一起走，
                一定会走到第一个相交点处

            3.有环链表找到相交节点： 会出现三种拓扑结构
                1.两个有环 不相交 “6 6”
                2.先相交 共享一个环 “Y形下面接个圆圈”
                3.连到一个环上 “倒A形”
            若loop1=loop2 ，则为情况2,等同于无环链表找相交节点，
            若loop1≠loop2，则可能为情况1或者3 
                则loop1继续遍历，若loop1.next遍历到loop1 则为情况1
                                若loop1.next遍历到loop2, 则为情况2 返回loop1或loop2
    .