# 并查集
    1.快速的检查两个元素是否属于一个集合 isSameSet(A,B)
    2.两个元素各自所在的集合合并在一起   union(A,B) 合并元素AB所在的集合
    3.以点为操作单位而不是集合
    4.需要一次性把样本给齐，不能适用于流这种实时来数据的操作。
    5.使用list或者set都不适合

    1.每个点都有一个指向自己的指针
    2.两个点合并，则B点的指针从B指向A，最上面有指向自己指针的是代表节点
    3.判断是否属于一个集合，则AB都往上找，代表节点相同则是同一集合
      合并：小的集合代表节点直接挂到大集合代表节点下面
    4.形状就像多叉树
    5.优化：   
        从B节点往上找完之后，把路径上的点都直接指向代表节点(变平) B下面的不变 
    6.若查询次数加合并次数在O(n)及以上，单次查询和合并的平均时间复杂度是O(1)


# 岛问题
    一个矩阵中只有0 1两种值，每个位置都可以和自己的上下左右四个位置相连，如果有一片1连在一起，这一部分叫做
    一个岛。求一个矩阵中有多少个岛？
    举例：
    0 0 1 0 1 0
    1 1 1 0 1 0 
    1 0 0 1 0 0 
    0 0 0 0 0 0 
    有三个岛

    思路：
        1.遍历矩阵，遇到1的点，个数记为1。然后用一个感染函数把该点附近为1的点全置为2。继续遍历，再遇到为1
        的点，继续感染，个数+1。
        2.感染函数时递归的。
        3.这是单CPU的思路
        4.多CPU的思路：
            1.当一个矩阵太大时，把它分解成多个矩阵进行计算，然后再合并起来
            2.边界信息如何合并？
            3.在感染时，把第一个点作为感染中心。每个矩阵区域最后得到两个值，一个是岛的数量，一个是边界的感染中心。
            4.只考虑边界点。假设有两个区域，左点和右点都是1，那么合并两个集合，岛的数量-1。左右点有一个不为1，不管，往下看。
            5.并查集完美解决已经合并过的区域不会重复减1.