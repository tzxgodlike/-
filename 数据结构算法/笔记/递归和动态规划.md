介绍递归 回溯 和动态规划 
    一类算法，不知道怎么算，但知道怎么试。
暴力递归： 
    1，把问题转化为规模缩小了的同类问题的子问题 
    2，有明确的不需要继续进行递归的条件(base case) 
    3，有当得到了子问题的结果之后的决策过程 
    4，不记录每一个 子问题的解
动态规划 
    1，从暴力递归中来 
    2，将每一个子问题的解记录下来，避免重复计算 
    3，把暴力递归的过程，抽象成了状态表达 
    4，并且存在化简状态表达，使其更加简洁的可能


[汉诺塔问题] 左中右三个杆 上有n个片 序号从上往下为1-n 只能小压大 从左移到右上 打印所有步骤 
    分解：
        1.把n-1部分当做整体，移到中间 
        2.把n移到右边，
        3.把n-1移到右边
    问题规模：T(n)=T(n-1)+1+T(n-1) 时间复杂度O(2^n)
    可以按代码中的，也可以定义六个状态转移函数彼此嵌套

[子序列问题]： 子序列中的字符在字符串中不一定是连在一起  子串要连载一起
    子序列就是子集问题，所以长度n的字符串有2^n个子序列 看图 
    指数规模联想到递归
    扩展：打印字符串的全排列 如ABC Print_All_Permutations
        思路：第一位选谁 有三种选择 (即A和A交换 A和B交换 A和C交换)
             选完之后考虑后两位 
# 经验 决策有3种时，就得循环了

[问题] 母牛每年生一只母牛，新出生的母牛成长三年后也能每年生一只 母牛，假设不会死。求N年后，母牛的数量。
    思路：F(n) = F(n-1)+F(n-3) 
    今年的牛= 去年的牛(不会死)+3年前的牛(才开始生小牛) 
    这种题写几个项然后找规律 
    递归是O(n) 这种都可以有一个简化的O(logn)的解法 进阶班会讲


# 怎么从暴力递归改为动态规划 哪些能改 哪些不能改
判断矩阵Null的情况
if(m==null||m.length==0||m[0]==null||m[0].length==0){
            return 0;
        }

[问题] 给你一个二维数组，二维数组中的每个数都是正数，要求从左上 角走到右下角，每一步只能向右或者向下。沿途经过的数字要累 加起来。返回最小的路径和。
    思路：
        1.暴力递归 
        2.满足无后效性 可以使用DP
        3.DP
            1.自顶向下 递归加备忘录 即重复计算的状态缓存 
            2.自底向上 状态转移表

[问题] Money_Problem  换零钱问题
    给你一个数组arr，和一个整数aim。如果可以任意选择arr中的 数字，能不能累加得到aim，返回true或者false
    思路：
        跟子序列一样 每个位置选择要还是不要