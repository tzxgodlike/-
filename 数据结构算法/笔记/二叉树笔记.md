二叉树的套路:递归函数很好用，因为它会回到一个节点三次。
来到X节点，一次。访问左子树再回到X，两次。访问右子树再回到X，三次。
因此，可以在X节点搜集左子树和右子树的信息来判断。

又叫 **树形DP** 就是在二叉树上做动态规划

# 树
    1.深度从0开始 层数从1开始 高度与深度相反
    2.完全二叉树的特殊意义在与 用数组存储时不会浪费数组空间
    3.

# 实现二叉树的先序、中序、后序遍历，包括递归和非递归方式
    1.递归方式
        按照先序遍历访问完整颗树会得到一个序列，取出第一次访问每个结点的序列，就是先序遍历，
        取出第二次访问每个结点的序列，就是中序遍历 取出最后一次访问每个结点的序列就是后序
        意思就是打印时机会决定遍历方式
    2.非递归方式-----使用栈
        树不能从下到上 所以需要一个结构 能从下回到上 所以使用栈 
        先序逻辑简单 中序代码规律 后序是先序的变种

# 直观的打印二叉树


# 在二叉树中找到一个节点的后继结点/前驱节点
    题目:有一种新的二叉树节点类型如下：
    public static class Node{
        public int value;
        public Node left;
        public Node right;
        public Node parent;
        public Node(int data){
            this.value = data;
        }
    }
    比普通二叉树多了一个指向父节点的指针。假设有一颗Node类型的节点组成的二叉树，树中每个结点的parent指针都正确的指向自己的父节点，头节点的parent指向null，只给一个在二叉树中的某节点node,实现返回node后继结点的函数。
    后继结点：在二叉树中序遍历序列中，node节点下一个节点叫做后继结点。

    解法：
        1.当x节点有右子树，后继结点必然是右子树最左的节点
        2.当x节点没有右子树，找左子树的最后一个节点为x的节点
            x节点通过parent指针网上找，找到y节点，y是它父亲节点的左孩子，y的父节点就是x的后继
        3.题目改为找前驱节点：
            1.若x节点有左子树，前驱节点必然是左子树最右的节点
            2.若x节点没有左子树，往上找，当前节点是父节点的右孩子，则返回父亲节点

# 二叉树的序列化与反序列化
    每个结点后都需要一个“_”分隔符来区分。
    先序的序列化
    按层遍历的序列化 
        层次遍历的思路：用一个队列，先把head打印再放进去。然后循环，队列非空时，出队。判断该节点有无子节点，有则打印子节点并入队。

# 判断一棵树是否是平衡二叉树
    平衡二叉树：所有子树的子树高度差小于等于1
    来到X节点时，如何判断：
        1.左树是否平衡
        2.右树是否平衡
        3.左树高度，右树高度+

        .

        3

# 判断一棵树是否适合搜索二叉树、判断一棵树是否是完全二叉树
    搜索二叉树：对于任意节点，左子树都比它小，右子树都比它大。所以中序遍历为依次升序的为搜索二叉树。
        通常不出现重复节点，把重复节点的信息压缩到一个节点的list里面。
    方法：在中序遍历的非递归方法中，把打印的时机改为比较的时机。打印出来的顺序应该是升序的，用pre记录上次要打印的值，与head.value比较 若大于 则false

    完全二叉树：上一层是满二叉树 最后一层从左到右依次补齐
    方法：
        1.节点有右孩子没有左孩子，false
        2.不满足第一点的同时，如果一个节点不是左右孩子都全(即没孩子或者只有左孩子)(则开启一个判断状态)，后续节点必须全是叶节点。

# 已知一颗完全二叉树，求其节点的个数 要求时间复杂度低于O(n) N为结点个数 
    递归问题
    