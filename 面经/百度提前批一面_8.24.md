百度提前批一面  [挂]
    1.设计秒杀系统

    2.用的restful还是httptemplate

    3.String 和 StringBuilder区别

    4.http过程 包含了讲解TCP三次握手 四次挥手过程

    5.HTTP返回码

    6.leetcode 判断有效括号

        1.简单题 不要想的太复杂 先用一个map对应左括号和右括号
        在用一个栈 遇到左括号就进栈 遇到右括号 则看出栈的字符是否
        与该右括号匹配；若栈空 直接返回后false    

京东一面   
    
    1.事务的传播机制   就是A方法有事务 A调用了B  那B得事务是什么

        1.你们定时任务操作一半出异常 是回滚还是继续提交啊

        2.
    
    2.redis故障转移

    3.springcloud的一些流程

    4.redis怎么实现热点商品啊 list 怎么秒杀

    5. 其实是数据库的线程安全 多线程读取你的同一条数据记录去生成发票怎么办 用一个状态 在开票的状态为开票中

    6.如何实现行锁  

    7. 学生 课程 分数  如何查出每门课都高于80分的学生  用min函数 >80就行


美团快驴一面

    1.指令重排序 在多线程的情况下会出现问题。 degug单步调试不会做优化，所以不会重排序，而是顺序执行。

    2.redis 如何集群  

    3.eureka 服务发现注册的原理：
        服务把自己的信息发送给注册中心

    4.eureka 集群保持一致性原理
        1.节点同步分为：
            1.主从复制 所有写操作提交到主服务，再由主服务更新到从服务；写压力集中在主服务上，从服务分担读请求；
            2.对等复制 副本间不分主从，任何副本都可以接受写操作，然后副本间进行数据更新；但副本间数据同步时可能产生数据冲突；
        
        2.通过一个时间戳 来判断哪个节点的数据最新

    5. 求topK

        1.最小堆 与堆顶比较
        2.分治法 5万个数 内存只能占1万个数 分成5份 找出每份中的topK 在拿出5份topK放入内存
    
    6. 外部排序

        1.先把大文件分成n份 排好序 再归并排序
    
    7. DUBBO的服务暴露 引用 ZOOKEEPER  敖丙的文章

    8. 红黑树与二叉平衡树AVL的区别

        1.红黑树放弃了追求完全平衡，追求大致平衡，在与平衡二叉树的时间复杂度相差不大的情况下，保证每次插入最多只需要三次旋转就能达到平衡，实现起来也更为简单。

        2、平衡二叉树追求绝对平衡，条件比较苛刻，实现起来比较麻烦，每次插入新节点之后需要旋转的次数不能预知。


## Shopee 

    1.服务端发送字符串 怎么判断是tcp的一个报文还是两个报文发来的

    2. 数据库怎么实现持久化

    3. TCP基于流和UDP基于报文的区别

        1.TCP为了保证可靠传输并减少额外的开销（每次发包都要验证），采用了基于流的传输，基于流的传输不认为消息是一条一条的，是无保护消息边界的（保护消息边界：指传输协议把数据当做一条独立的消息在网上传输，接收端一次只能接受一条独立的消息）。

        UDP则是面向消息传输的，是有保护消息边界的，接收方一次只接受一条独立的信息，所以不存在粘包问题。

        举个例子：有三个数据包，大小分别为2k、4k、6k，如果采用UDP发送的话，不管接受方的接收缓存有多大，我们必须要进行至少三次以上的发送才能把数据包发送完，但是使用TCP协议发送的话，我们只需要接受方的接收缓存有12k的大小，就可以一次把这3个数据包全部发送完毕。

    4. TCP粘包 那如何判断TCP发送的字符串是一次来的还是二次来的？

        1.发送长度：发送每条数据时，将数据的长度一并发送，例如规定数据的前4位是数据的长度，应用层在处理时可以根据长度来判断每个分组的开始和结束位置。

        2. 格式化数据 即每次发送的数据定长


        3.参见NETTY解决TCP粘包 自定义协议 定以一个MessageProtocol类 规定消息的长度 和内容  然后编码解码安装这个规定来实现

    5. 僵尸进程： 就是父进程在调用子进程时，子进程优先结束 但父进程没有回收进程，释放子进程占用的资源。此时子进程成为僵尸进程。可以让父进程调用wait函数获取子进程的状态信息。

    6. 孤儿进程： 父进程退出，而它的一个或多个子进程还在运行，成为孤儿进程。

    7. 守护进程： 守护进程没有存在的父进程，在后台执行。 一个子进程调用fork,然后使其父进程立即终止，使得这个子进程能在init下运行。 

## 华为面经

    1.函数调用在栈里面的过程

    2.String的问题  

    3.运行时多态  编译时多态

        1.方法重载  编译时多态  根据实际参数来在编译时确定执行哪一个方法

        2. 方法覆盖表现出两种多态性。

            1.如果是F f = new S();    f.B();    //F S 中都有A方法  S独有B方法  
            那么f.B() 在编译时按照F的方法表编译  在运行时实际执行需要查找S的方法表 S有 则执行子类的方法 没有 执行父类的方法

            在运行时 java从实例所在的类开始找 即new 的那个类开始往上找一直到Object类  

    4.


## 网易互娱一面

    1. java的修饰符的访问限制

    2. 为什么移位操作快？

        因为移位指令占2个机器周期，而乘除法指令占4个机器周期

        二进制也是无法直接实现乘除法 会变为加减法

    3. 分段分页  虚拟内存的作用  程序分为程序段 数据段 堆栈     

    4. 怎么知道栈是高寻址还是低寻址 

        1. 运行时 查看指针的地址

        2. 不运行  在编译之后 查看每个函数的入口
    
    5.超卖  用lua给redis加锁

    6.怎么实时生成排名？    桶排序  类似于一分一段表  [你只需要你在多少名 不需要知道整个的排序情况]

    7. SLEEP 进入阻塞态而不是就绪态 

    8. yeild 让出时间片 进入就绪态
       sleep  进入阻塞态
       join   新建线程s  主线程调用s.join 让主线程进入wait 中阻塞 知道s执行完 再唤醒主线程
            1.wait()的作用是让“当前线程”等待，而这里的“当前线程”是指当前在CPU上运行的线程。所以，虽然是调用子线程的wait()方法，但是它是通过“主线程”去调用的；所以，休眠的是主线程，而不是“子线程”！


## 小米一面

    1.为什么zset用跳表 ？  支持区间查找 其实跟B+树作用一样的 

    2.


## OPPO 二面

    1. 什么场景下会使用索引 

    2. ThreadLocal怎么实现  如果不remove掉会发生什么？

        1.<key,value> 中key是软引用 会被回收 value 是强引用  不会被回收 出现内存泄漏

        2.key为ThreahLocal变量 value为set的变量副本

        3.为什么key是弱引用 value强引用？

            1.当ThreahLocal被回收的时候 强引用使得map里面的key不会被回收

            2.如果value是弱引用 那么其他线程回收ob 会让value变为null
         
    
    3. lock A {
        lock B {

        }
    }
    如果不释放B 直接释放A  那么多线程下 会死锁

    4. git分支怎么管理 

## 网易杭研一面

    1.序列化的UUID

        1.反序列化时系统会去检测文件中的serialVersionUID，判断它是否与当前类的serialVersionUID一致

        2.

    2.CAP

    3.隔离级别的实现

        1.见重点知识梳理

    4.静态方法调用成员变量的问题 

        1.静态方法不属于对象，是属于类的，是不需要实例化的，而非静态变量是属于对象的，需要先实例化。在一个类的静态成员中去访问其非静态成员之所以会出错是因为在类的非静态成员不存在的时候类的静态成员就已经存在了，访问一个内存中不存在的东西当然会出错。

    5. linux动态的查看日志文件

        1.tailf   从开头读

        2.tailf  -f 从尾部开始读

    6. 泛型
        1.把类型明确的工作推迟到创建对象或调用方法的时候才去明确的特殊的类型   把类型当作参数一样传递

        2.为什么不用Object ？   

            1.Collection、Map集合对元素的类型是没有任何限制的。本来我的Collection集合装载的是全部的Dog对象，但是外边把Cat对象存储到集合中，是没有任何语法错误的。

            即Collection<Object> 你可以穿任何类型进去 但Collection<E> 虽然没有指定类型 但也只能传一种类型进去

            2.把对象扔进集合中，集合是不知道元素的类型是什么的，仅仅知道是Object。因此在get()的时候，返回的是Object。外边获取该对象，还需要强制转换

            3.可以使用增强for循环  因为在创建集合的时候就明确了类型
    
    7. https加密

        1. 公钥加密 私钥解密   A给B发消息 A要用B的公钥加密

        2. 私钥签名 公钥验证   B用私钥加密签名 A用B的公钥解密 验证是否是B

        3. 需要第三方来验证 证书管理机构CA  A申请一个CA的证书 发过去 B使用CA的公钥验证 然后就是用B的公钥开始加密DES的密钥发送