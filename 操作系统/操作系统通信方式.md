## 管道

    1. netstat -tulnp|grep 8080
        
        1. "|"是管道的意思,把前一条命令的输出结果作为后一条命令的输入。 
        2.这样可以作为两个进程间的通信，且|没有名字，成为匿名管道
        3.该通信方式是单向的
    
    2. 命名管道

        1.mkfifo test                    //创建名为test的管道
          echo "this is a pipe" > test   //写数据
          cat < test                     //读数据

    3. 缺点 
        1.比较简单 类似于缓存 一个进程把数据放在某个缓存区域 然后等另一个进程去拿 
        2.效率低下  a进程要等b进程拿了数据才能返回
    

## 消息队列 

    1.把要发送的消息拷贝到消息队列 b线程需要的时候再去取  就不用a线程等待了 
    2.缺点 消息太多时 拷贝需要很多时间来读内存



## 共享内存

    1.系统加载一个进程时，分配的是虚拟内存空间， 让2个进程各自拿出一块虚拟内存映射到
    相同的物理内存中，就实现了内存共享


## 信号量

    1.本质是一个计数器，用来实现进程间的互斥和同步
    
    2.初始值设为1 a进程访问时-1为0 b进程来看到为1就知道不能访问了

## socket

    1.不同主机之间的通信



## Linux进程

https://blog.csdn.net/nan_lei/article/details/81636473 关于进程的博客

    1.孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。

　　2.僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。

    3. 子进程是父进程的复制品

        1.创建子进程的方法是使用系统调用fork()函数

        2.子进程完全复制了父进程的资源，包括进程上下文、代码区、数据区、堆区、栈区、内存信息、打开文件的文件描述符、信号处理函数、进程优先级、进程组号、当前工作目录、根目录、资源限制和控制终端等信息，而子进程与父进程的区别有进程号、资源使用情况和计时器等。

        3.写时复制技术（copy on write）：内核只为新生成的子进程创建虚拟空间结构，它们来复制于父进程的虚拟究竟结构，但是不为这些段分配物理内存，它们共享父进程的物理空间，当父子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间。

        4.在父进程中，fork()函数会将子进程的PID返回给父进程，即父进程的pid变量内存储的是一个大于0的整数；
          而在子进程中，fork()函数会返回0，即子进程的pid变量内存储的是0；如果创建进程出现错误，则会返回-1，不会创建子进程。
    
        5.通常情况下，我们首先使用fork()函数创建一个子进程，然后调用 [exec函数族] 内函数将子进程内程序替换成其他的可执行程序，这样看起来就像父进程诞生了一个新的且完全不同于父进程的子进程。

        6.当我们需要结束一个进程的时候，我们可以使用exit()函数或_exit()函数来终止该进程。当程序运行到exit()函数或_exit()函数时，进程会无条件停止剩下的所有操作，并进行清理工作，最终将进程停止。

        7.wait()函数用于使父进程阻塞，直到父进程接收到一个它的子进程已经结束的信号为止。如果该进程没有子进程或所有子进程都已结束，则wait()函数会立即返回-1。