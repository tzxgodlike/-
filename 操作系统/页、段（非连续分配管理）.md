# 页、段（非连续分配管理）

## 基本分页存储管理

### 把内存分为一个个相等的小分区，再按照分区大小把进程拆分成一个个小部分

- 内存中大小相等的小分区就成为“页帧”
- 把用户进程也拆分为相等的小区域，成为“页”
- 此时进程页面再内存中不是按顺序和连续存放 那如何实现逻辑到物理地址的转换？

	- 先算逻辑地址对应的页号
	- 再找该页对应页帧在内存中的起始地址
	- 再根据逻辑地址在页中的偏移量+上面的起始地址
	- 页号 = 逻辑地址/页面长度
	- 页内偏移量=逻辑地址%页面长度

### 逻辑地址结构

- 若用32位来表示地址 页面大小为2^10 那么前22位表示页号 后10位标识页内偏移量
- 页面大小2^10 一个进程最多有2^22个页

### 页表

- 页号和页帧号的对应关系  即进程页面和实际存放的内存块之间的对应关系

	- 页表的每一项都是按顺序连续存放的 所以页号可以隐含 只需要保存页帧号 还有页表的起始地址

		- 页是定长 所以不需要存页长

- 页表的长度

	- 就是内存/页大小 = 页面的个数

- 页表项的大小（就是页帧号的长度）

	- 就是页表长度需要用二进制表示的位数(字节数) 。一般大小设置为一个页能装下整数个页表项

		- 内存4GB 页面4KB 那么有2^20个页 页帧号的范围就是0~2^20-1 所以要20位数字来表示页帧号  即一个页表项有3个字节(24位)大小 

- 页表存放在内存的连续空间中

### 基本地址变换机构

- 逻辑地址、页表起始地址、页帧号 = 物理地址

  1.根据逻辑地址算页号 偏移量
  2.页号与页表长度对比 超过则中断
  3.根据页表起始地址、页号和页表项长度找到对应页表项
  4.根据页表项对应的页帧号 找到物理地址

- 页表寄存器

	- 页表起始地址
	- 页表长度
	- 在PCB中

- 访问了两次内存

	- 查页表
	- 访问目标内存块

### 具有块表的地址变换机构

- 块表不在内存中，在另一块访问速度更快的区域
- 先去查快表，若没命中，则再去内存慢表中找，并把该页表项复制到快表中。若命中，直接去内存拿。
- 局部性原理

	- 时间局部性

		- 某条指令或数据被访问之后很可能继续被访问

	- 空间局部性

		- 某存储单元被访问后其相邻的存储单元页很有可能被访问

### 两级页表

- 单级页表存在的问题

	- 页表必须连续存放，页表较大时 会占用很多个连续页帧
	- 没有必要让整个页表常驻内存 因为进程一段时间内可能只需要访问几个特定的页面

- 问题1解决：之前为了让程序在内存中离散分配，使用了页表 那么让页表也能离散存储，就再对页表建立一个页表 即两级索引
- 问题2解决：需要访问页面时才把页面调入内存（虚拟存储技术） 再页表项中增加一个标志位，表示该页面是否已经调入内存
- 细节：各级页表大小不能超过i一个页面，超过了就再建立一级。如页号有28位，一个页只能放10个页表项，那就分成8+10+10三个页表

## 基本分段存储管理

### 什么是分段?

- 进程按自身的逻辑关系(如函数名)划分若干段，有段名。
- 段，就是放大的页

### 段表

- 存放段号、段长C和段基址b

	- 页长都是定长，而段每个长度都不一样

- 每个段表项的长度是相同的，所以段号也可以隐含，不占内存空间。K号段在段表中的位置可以由段表起始位置加段号乘段表项长得到。

### 内存的系统区中的PCB中由段表寄存器

- 段表起始地址F
- 段表长度M

### 地址转换

- 逻辑地址中有段号S 段内地址W
- 先S和M判断 是否越界产生内中断
- F+S*段表项长度求出段表项地址
- W与该段表项对应的段长C比较是否越界
- 段基址b+段内地址W = 物理地址

### 也可以引入快表

### 和动态分区的对比

- 动态分区分配是分配多个进程  是连续分配
- 分段是进程内分段 是非连续分配

## 分段分页对比

### 页是物理单位，对用户不可见。段是逻辑单位，对用户可见

### 页大小固定，由系统决定。段长度不固定，决定与用户编写的程序

### 分页的地址空间一维，只需要一个记忆符。分段是二维，需要程序员标识段名和段内地址。

### 分段利于信息共享。如多个进程的段表的某段表项指向同一个段。

## 段页式存储管理

### 将进程按逻辑模块分段，再将各段分页，再将内存空间分为大小相同的页帧

### 段号 页号 页内偏移量

### 段表[页表长度 页表存放块号]  页表[内存块号] 段号页号都是隐含的 由逻辑地址算出

### 访问了三次内存[段表 页表 物理地址]

### 可以建立快表 用段号和页号作为查询的关键字

*XMind - Trial Version*