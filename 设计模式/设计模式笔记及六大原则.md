
## 建造者模式 builder
    
    1.一个抽象类builder 若干builder子类（负责给实体类传参 不同子类给实体类传的参数不同） 一个实体类 一个监工类director director(bulider).construct()方法来构造builder子类对象
        
        监工类中把传入的子类都转化为父类 不能改变零件 但是能决定零件组合的顺序 不同顺序对应不同的construct
    

    3.关于Builder模式，我们一定要分清和模板方法的区别，其实就是到底谁承担了"监工"的责任，在模板方法中父类承担了这个责任，
    而在Builder中，有另外一个专门的类来完成这样的操作，这样做的好处是类的隔离，比如说在Main中，用户根本就不知道有Builder这个抽象类，同样的Director这个监工的根本就不管到底是哪一个实现类，因为任何一个都会被转换为父类，然后进行处理（面向抽象编程的思想），因此很好的实现了隔离，同样的这样设计的好处是复用了，隔离的越好复用起来就越方便，我们完全可以思考，假如还有另外一个监工，使用了不同的construct方法来组装这些复杂的事件，那么对于原来的代码我们不用做任何的修改，只用增加这样的一个监工类，然后定义好相应的方法就好了，之后再Main中使用，这样的一种思想使得我们不用修改源代码，复用（Builder以及其子类）就很方便了，同样的，如果想增加一个新的Builder的子类，只要照着父类的方法进行填充，再加上自己的方法就好了，完全不用修改代码，这也是一种复用，因此这种复用（组件）的思想在设计模式中随处可见，本质就是高内聚低耦合，组件开发，尽量不修改原来的代码，有可扩展性，理解了这一点，我们再看看模板方法，责任全放在了父类里，如果责任需要改变，则必须要修改父类中的责任方法了，这样就修改了原来的代码，不利于复用，这也是两者的本质区别。    
    
    4.https://juejin.im/post/5a23bdd36fb9a045272568a6
    这篇文章讲的很详细
    在盖房子这个案例中 如果不使用建造者模式直接调用bulider的方法 那么写代码的人需要知道调用builder中方法的顺序
    而建造者模式把这个顺序封装在了director中 写代码的人直接调用它的construct就行
    
    表面上看 只是封装了一层这么简单 实际上在开发中 可能各层的编写人员是不一样的 这一层的人不需要知道下一层函数的具体细节 只需要根据功能调用下一层就行
    
    5. 另一用处：如果我们想要调用这个类就得在构参数方法中传递“无数个参数”「如果有的参是一些可选项，我们还得重写构造方法」，要么就要调用多个 setter 方法，才能给一个对象赋值，方法虽然可行，但是也太扯淡了「谁能记住那些参数呀」，那么建造者模式可以解决多参数构造方法来建造对象
    
    我们分别使用普通构造方法「调用者能吐血」和建造者模式组装电脑，可以看到建造者模式调用 new ComputerB.ComputerBuilder(xxx).setxxx().setxxx().build()     调用方法直接打点调用「也叫流式调用，这样调用方便多了，想点那个就点那个    

    6. 代码实现
        
        1. 实体类（被建造的类）  A
        2. 抽象Builder类或接口   定义设置A属性的方法  最后定义一个返回A对象的方法         
        3. Builder实现子类       ChildBuider  实现接口方法
        4. Director  建工类      持有一个Builder引用 director(bulider).construct()中按自定义顺序调用Builder中接口方法（来对A实体类的属性赋值） construct()最后返回一个A对象
        5. 调用过程
            ...
            Builder b = new ChildBuider();
            Director d = new Director(b);
            A a = d.construct();
            ...
        6.建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系

## 原型模式      
    
    1.要复制对象时  实现cloneable接口 直接obj.clone()

##  模板模式
    
    1.父类定义抽象方法 子类覆盖实现
    
    2.1、封装不变部分，扩展可变部分。 2、提取公共代码，便于维护。 3、行为由父类控制，子类实现。
    
    3.代码实现    
        
        1.父类
        ···Java
        public abstract class Game {
            abstract void initialize();
            abstract void startPlay();
            abstract void endPlay();
         
            //模板
            public final void play(){     //父类定义行为 
         
              //初始化游戏
              initialize();
         
              //开始游戏
              startPlay();
         
              //结束游戏
              endPlay();
            }
        }    
        ···
        
        
        2.子类覆盖抽象方法 实现行为

## 中介者模式
    
    1.普通模式中，小明要看房，则需要在自身类中带有每个房子的对象引用 是一对多
    
    2.在终结者模式中，我们可以看到小明和经纪人是一对一关系，经纪人和房东是一对多关系。小明找房经历也轻松多了，只花了一下午就把房子都看了并看中了。
    这也是中介者模式的优点，减少了不必要的依赖，降低了类间的耦合。
    
    3.MVC层中Controller层也是作为中介
    
## 命令模式
    
    1.一般来说 请求的发起者和请求的执行者是强耦合的 比如一个经理 是任务请求发起 一个员工 是执行者 经理向员工发出任务执行命令和任务终止命令
    那么经理类肯定要引用一个员工类对象
    
    2.现在要把经理类和员工类解耦 新建一个抽象的命令类  命令实现子类中有员工的引用 和execute(参数：请求)方法  
    经理类中有命令父类的引用  发出任务命令时 先执行setCommand 设置任务类型 再action方法 去执行command.execute方法
    
    3.每一个命令都是一个操作：请求的一方发出请求，要求执行一个操作；接收的一方收到请求，并执行操作。
    命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。
    命令模式使请求本身成为一个对象，这个对象和其他对象一样可以被存储和传递。
    命令模式的关键在于引入了抽象命令接口，且发送者针对抽象命令接口编程，只有实现了抽象命令接口的具体命令才能与接收者相关联。
    
    4.其实就是加了1层 用command 包装员工的行为  
    

## 策略模式
    
    1.常与简单工厂模式合用
    2.客户端调用者知道具体的策略子类

## 工厂模式汇总
    
    1.简单工厂
        1.某抽象类有ABC三个子类 在工厂的构造方法中通过switch参数 来决定创建哪个子类  （客户端不知道具体子类）
        如果要新加入一个子类 就要修改构造方法 违反原则
        
        2. 简而言之 简单工厂不是23种之一。她就是用一个Factory类 通过传入的参数 决定生成什么实体类
        
         3. 代码
            ···
            Mouse m = MouseFactory.createMouse(0)   //生成AMouse或者BMouse
            ···
            
    2.工厂方法
        
        1.MouseFactory变成接口 生成哪个类由其对应的AMouseFactory子类决定
        
        2.代码    
            Mouse m = new AMouseFactory.createMouse();
            
        3.所以构建三个ABC的仓库 要创建哪个子类 直接new该子类的构造方法  （客户端知道具体子类）
        
    3.抽象方法
        
        1.超级工厂  即工厂的工厂 通过参数A或者客户端指定来生成某个具体的工厂 再通过参数B来决定生成哪个产品
            
            1.前面的都是以一个参数就确定产品 这里先用参数A来确定哪个工厂（宝马还是奔驰） 
             再用参数B来确定哪个产品（轮胎还是方向盘）
        2.工厂方法是在解决一个产品多个层级方面的事情；而抽象工厂致力于解决多个产品多个层级方面的事情。举个例子：汽车是由很多零件组成的，比如引擎、轮胎、方向盘等等。现在如果我们是轮胎生产方，要生产宝马轮胎和奔驰轮胎，要用工厂方法还是抽象工厂实现呢？答案是：工厂方法。轮胎是一个产品，宝马轮胎和奔驰轮胎是 2 个不同层级的轮胎，所以用工厂方法解决就足够。假如现在我们是汽车生产方，要生产宝马汽车和奔驰汽车，汽车又包含轮胎和方向盘等等，要用哪个来实现？既然是上面的是工厂方法，那这个就用抽象工厂，因为这涉及到多个产品（轮胎、方向盘等等）和 2 个层级（宝马和奔驰）。
        
        
## 迭代器模式
    

## 观察者模式
    
    1.被观察者用一个list存观察者 并实现注册观察者 移除观察者 通知观察者(调用观察者的update方法)等方法   
    观察者实现update方法 

## 状态模式   https://mp.weixin.qq.com/s/idqYPpzR8kbG4gz11EnY1Q

    1.案例：用户有注册、授信、借款三种行为，通过一个state(游客、注册用户、授信用户、借款用户)属性来做权限控制。  
    那么三种行为方法中要判断4次来决定该用户状态是否能执行该方法 如果新增一个状态 那么需要修改发i所有的行为方法
    
    2.把状态这个属性抽出来 作为一个State接口 把注册、授信、借款等方法作为接口方法  User持有State引用  有一个setState函数   把user原有的行为方法里调用state对应的行为方法
    
    3.代码
    User {
       State s
       setState(State s)
       public void register() {
        this.state.register();     //原始的register需要if/else判断state属于哪种状态
        }
        ..等若干行为方法                 
    }
    
    interface State{
        register();
        ...等方法
    }
    
    class RegisterState implements State{
        @Override
        public void register() {
            System.out.println("注册用户。不需要再注册。");
        }
        
        ...等方法
    }
    
    主代码
    user.setState(new RegisterState());
    user.register();
    
     
    4.这也是为什么《阿里巴巴 Java 开发手册》里面讲的，当 行为方法中 超过 3 层的 if-else 的逻辑判断代码，推荐用状态模式来重构代码。
        
## 备忘录模式
    
    1.做一个备份
    
    2.客户不与备忘录类耦合，与备忘录管理类耦合 

## 解释器模式
    
    1.把Java转化为sql       ORM

## 访问者模式
    
    1.在数据基础类里面有一个方法接受访问者，将自身引用传入访问者。
    


## 适配器模式    spring cloud中用到
    
    1.把两个不兼容的接口链接起来
    
    2.类A 要适配成B接口  那么创建一个适配器类  持有A类的引用  覆盖B接口的实现方法 在方法内部调用A类的原方法

## 桥接模式
    
    1.将抽象和实现解耦
    
    2.抽象类 手机 抽象方法openSoftware 实现类 IOS手机和安卓手机   持有软件实现类的引用        软件 实现子类有方法open 不同的系统 软件打开的方法会不同
    openSoftware中调用软件实现类的open·方法 把自身手机对象作为参数传入

## 组合模式
    
    1.案例： 一个经理下面有若干组长 一个组长下面有若干工程师
    
    2.把三个角色的共同点抽象出一个抽象类   
        
        1.经理和组长 角色 功能一样 可以合并为一个领导子类

        2.职工为一个子类 并且有自己的功能
        
    3. 安全模式和透明模式
        
        1.安全模式中  领导和职工自己特有的方法没有定义在抽象类中
        
        2.透明模式中 把所有方法都定义在抽象类中 只是有的子类没有该功能 则不实现该方法（造成没有功能也有该方法）
    
## 装饰器模式
    
    1.动态的给类添加额外的功能 比生成子类更加灵活 
    
    2.核心就是用一个装饰类把原实体类（有方法A）包装起来 该装饰抽象类继承了原实体类 持有原实体类的引用 有抽象方法A
    
    在装饰类的实现子类中重写A方法（先调用原实体类引用的A方法， 再添加功能）
    
    3.装饰抽象类继承原实体类的目的是 可以把某实现子类继续当构造参数  传给下一个装饰子类 继续添加功能

## 外观模式
    
    1.案例： 原来是开发人员和需求人员互相引用  引入外观模式后 又加了一各leader层 持有开发的引用 需求持有leader的引用 
    
    2.外观模式通过一个对外统一的接口，隐藏了内部的具体实现，使得外部系统可以更加简单的访问，也减少了外部系统对内部系统的依赖，从上面的例子讲，如果开发同学开发一半生病短时间无法来上班，交接给其他同学，由组长内部安排解决，需求同学并不需要知道。外观模式在微服务交互之间经常使用。
    
    3. 核心就是加了一层 需求方不够管具体需要几个研发 测试  交给leader类去管理
    
## 享元模式
    
    1. 系统中有大量对象。 2、这些对象消耗大量内存。 3、这些对象的状态大部分可以外部化。 4、这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中剔除出来时，每一组对象都可以用一个对象来代替。 5、系统不依赖于这些对象身份，这些对象是不可分辨的。
    
    
    2. 关键代码 用hashmap存储这些对象

## 











### 设计模式六大原则

## 单一职责原则
    
    1.单一职责原则适用的范围有接口、方法、类。接口和方法必须保证单一职责，类就不必保证，只要符合业务就行。
    
    
## 里氏替换原则
    
    1.子类可以扩展父类的功能，但不能改变父类原有的功能
    
    2.即最好不要重写或者重载父类的方法


## 依赖倒置原则

    1.高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。
    
    2.核心：  面向接口编程 
        
        1.类A 依赖类B 如果类A要改为依赖类C 则要去A中修改代码。
        2.这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。
        
        3. 创建接口I  将类B C实现接口I  A直接依赖I 那么就不用修改


## 接口隔离原则
    
    1.客户端不应该依赖它不需要的接口。 类间的依赖关系应该建立在最小的接口上。
    
    2.将一个大的接口拆分为若干小接口 也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用
    
    
## 迪米特法则 （最少知识原则）
    
    1.一个对象应该对其他对象保持最少的了解
    
    2.即尽量降低类与类之间的耦合 没有直接关系的类不要作为成员变量出现在该类内部
    
    2.迪米特法则的初衷是降低类之间的耦合，由于每个类都减少了不必要的依赖，因此的确可以降低耦合关系。但是凡事都有度，虽然可以避免与非直接的类通信，但是要通信，必然会通过一个“中介”来发生联系，例如本例中，总公司就是通过分公司这个“中介”来与分公司的员工发生联系的。过分的使用迪米特原则，会产生大量这样的中介和传递类，导致系统复杂度变大。所以在采用迪米特法则时要反复权衡，既做到结构清晰，又要高内聚低耦合。

## 开闭原则

    1.应该对于扩展是开放的，但是对于修改是封闭的
    
    2.用抽象构建框架，用实现扩展细节
    
    3.其实，我们遵循设计模式前面5大原则，以及使用23种设计模式的目的就是遵循开闭原则。也就是说，只要我们对前面5项原则遵守的好了，设计出的软件自然是符合开闭原则的，这个开闭原则更像是前面五项原则遵守程度的“平均得分”
    
    4.
## 高内聚 低耦合
    
    1.内聚：每个模块尽可能独立完成自己的功能，不依赖于模块外部的代码。
    耦合：模块与模块之间接口的复杂程度，模块之间联系越复杂耦合度越高，牵一发而动全身。
    目的：使得模块的“可重用性”、“移植性”大大增强