1.接口与抽象类
    1.抽象类使用abstract声明 不能被实例化 只能被继承 子类覆盖抽象方法
    2.接口有默认的方法实现，成员都是public 字段默认是final和static
    3.使用接口：
        1.不相关的类都实现一个方法，如不相关的类实现comparable接口的
        compareto方法
        2.需要使用多重继承
      使用抽象类：
        在几个相关的类中共享代码
        需要控制继承来的成员的访问权限 而不是都为public
        需要继承非静态和非常量字段

类修饰符：public 、default (默认)
    1.public 适用于任何权限
    2.不加public 会默认default 该类只能被同一个包的类访问 父包子包都不可以访问

属性方法修饰符：
    public、private、protected、default （默认）
    1.类中属性、方法用 private 修饰，仅可于当前类访问
    2.类中属性、方法不加任何修饰符，仅可于同一个包名下访问（子包、父包不可访问）不同包的子类都不可以访问
    3.类中属性、方法使用 protected 修饰，可在不受限于不同包名该类子类访问，以及同一个包名仍可访问。
    4.类中属性、方法用public 可以被任何类访问

值传递：
    1.参数传入的是变量的副本
    2.变量为基本类型 那么不会改变原变量的值
    3.变量为引用类型，会改变原变量的值 因为传进来得是引用的值 相当于钥匙 拿到钥匙可以进入房间修改对象的值
    4.变量为string  当String作为形参传递到方法里的时候,实际上传递的是str引用的拷贝 但是因为strng是不可变的 在方法中改变string，引用的拷贝会指向新建的string
    也就影响不到外面的string了 
    5.变量为数组时 相当于引用 会改变原来变量的值 


2.final关键字
    1.作用于变量
        1.对于一个final变量，如果是基本数据类型的变量，则其数值一旦在
        初始化之后便不能更改；
        2.如果是引用类型的变量，则在对其初始化之后，便不能再让其指向另一个对象
    2.作用于类
        1.这个类不能被继承，类中方法隐式的被指定为final
    3.作用于方法
        1.不能被继承修改
3.static关键字
    1.修饰成员变量、成员方法
        1.被修饰的变量属于这个类而不是单个某个对象，被类中所有对象共享，并可以
        通过类名调用，存放在方法区
    2.静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行
    (静态代码块—>非静态代码块—>构造方法)。 该类不管创建多少对象，
    静态代码块只执行一次.
      静态代码块在类被主动调用时执行 在类被初始化时执行
    3.静态内部类（static修饰类的话只能修饰内部类）：静态内部类与非
    静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会
    隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类
    却没有。没有这个引用就意味着：
        1. 它的创建是不需要依赖外围类的创建。
        2. 它不能使用任何外围类的非static成员变量和方法。
    4.调用顺序
    先初始化父类和子类的静态成员变量，之后在是按结构初始化父类（变量，构造函数）和子类（变量构造函数）。
    5.父类被static修饰的变量 如子类中没有该变量 子类实例修改该变量会导致父类变量修改 而未被static修饰的变量不会
4.equals == hashcode
    1.若某个类没有覆盖equals()方法，当它的通过equals()比较两个对象时，实际上
    是比较两个对象是不是同一个对象。这时，等价于通过“==”去比较这两个对象。
    2.我们可以覆盖类的equals()方法，来让equals()通过其它方式比较两个对象
    是否相等。通常的做法是：若两个对象的内容相等，则equals()方法返回true；否则，返回fasle。
    3.hashcode作用是获取哈希码 在有hashset的场景下，会判断加入的key对象是否已经
    被加入过。此时就需要重写key对象的hashcode方法和equals方法，来保证不会加入内容相同的对象
    [比如，重写一个person的的equals方法,让内容相同时视为相等，但这两个对象加入
    hashset时还是会都加进去，再重写了hashcode方法，也让内容相同时视为相等，此时加入
    第二个对象就会覆盖第一个对象]

5.object.clone 

    1.java赋值是复制对象引用，如果我们想要得到一个对象的副本，使用赋值操作是无法达到目的
    即修改p2也会影响到p1

    2.创建一个对象的新的副本，也就是说他们的初始状态完全一样，但以后可以改变各自的状态
    
    而互不影响

    3.https://blog.csdn.net/u010947534/article/details/85050528
    clone的类中有引用对象时，这些引用类也需要实现cloneable接口
    
6. concurrentHashMap
    1.1.7 Segment 数组结构和 HashEntry 数组结构组成
        1.Segment 实现了 ReentrantLock,所以 Segment 是一种可重入锁，扮演锁的角色。
        HashEntry 用于存储键值对数据 即分段锁
    2. 1.8使用synchronized和CAS操作 
    synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍
    concurrentHashMap.computeIfAbsent 可以保证get和put的安全性
7. hashmap怎么put
    1.HashMap在put方法中，它使用hashCode()和equals()方法。当我们通过传递key-value对调用put方法的时候，
    HashMap使用Key hashCode()和哈希算法来找出存储key-value对的索引。如果索引处为空，则直接插入到对应的
    数组中，否则，判断是否是红黑树，若是，则红黑树插入，否则遍历链表，若长度超过8，则将链表转为红黑树，转成功之后 再插入。

8. 线程进程
    进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位

    在开销方面：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。

    所处环境：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）

    内存分配方面：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源。

    包含关系：进程是线程的容器，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。

    2.线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程
    共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈，
    
9. 堆和方法区
    是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (所有对象都在这里分配内存)，
    方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
10.上下文切换
    概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，
    可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。
11.sleep和wait的区别 
    sleep没有释放锁 wait释放了锁 

12.反射
    JAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，
    都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 java 语言的反射机制。

13.泛型
    把类型明确的工作推迟到创建对象或调用方法的时候才去明确的特殊的类型
    https://segmentfault.com/a/1190000014120746

14.get和post
    1.GET请求的数据会附在URL之后，以?分割URL和传输数据，参数之间以&相连，
    2.POST把提交的数据则放置在是HTTP包的包体中。
    3. get请求用来从服务器上获得资源，而post是用来向服务器提交数据

15.session和cookie
    1.Cookie 一般用来保存用户信息 比如①我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以
    自动帮你登录的一些基本信息给填了；②一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，
    这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可
    (为了安全考虑，重新登录一般要将 Token 重写)；③登录一次网站后访问网站其他页面不需要重新登录。
    2.Session 的主要作用就是通过服务端记录用户的状态。 典型的场景是购物车，当你要添加商品到购物车的时候，系统
    不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户
    并且跟踪这个用户了。
    3.Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。

16.java string 和char[]转化
    1. String s = String.valueOf('c'); //效率最高的方法
    2. String s = String.valueOf(new char[]{'c'}); //将一个char数组转换成String
    3. String s = Character.toString('c');
    // Character.toString(char)方法实际上直接返回String.valueOf(char)
    4. String s = new Character('c').toString();
    5. String s = "" + 'c';
    // 虽然这个方法很简单，但这是效率最低的方法
    // Java中的String Object的值实际上是不可变的，是一个final的变量。
    // 所以我们每次对String做出任何改变，都是初始化了一个全新的String Object并将原来的变量指向了这个新String。
    // 而Java对使用+运算符处理String相加进行了方法重载。
    // 字符串直接相加连接实际上调用了如下方法：
    // new StringBuilder().append("").append('c').toString();
    6. String s = new String(new char[]{'c'});


17. 创建大量对象时，jvm如何变化？

18. 消息队列如何实现分组？

19. 数据库如何去重？  distinct

20. map.put(1L,"1")之后  map.get(1)的值？   为null  因为get会自动装箱把1变为Integer对象 而1L是Long对象

21. hashmap 的多线程安全问题？

22. 双向链表和单向链表的查找和删除复杂度？   双向链表查找可以使用二分法

23. 

pdd:

    1.treemap leetcode 432  用treemap

    2.redis key过期的底层原理

    3.hystrix降级的底层原理

    4.合并K个有序链表  归并排序思想

    5.负载均衡算法实现

    6.操作系统文件管理

    7.编译原理 动态连接 静态链接

    8.DNS原理 迭代和递归

    9.一致性hash 避免了增加服务器之后的数据迁移

    10. 手写hashmap 
     