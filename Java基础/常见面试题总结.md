1.接口与抽象类
    1.抽象类使用abstract声明 不能被实例化 只能被继承 子类覆盖抽象方法
    2.接口有默认的方法实现，成员都是public 字段默认是final和static
    3.使用接口：
        1.不相关的类都实现一个方法，如不相关的类实现comparable接口的
        compareto方法
        2.需要使用多重继承
      使用抽象类：
        在几个相关的类中共享代码
        需要控制继承来的成员的访问权限 而不是都为public
        需要继承非静态和非常量字段
2.final关键字
    1.作用于变量
        1.对于一个final变量，如果是基本数据类型的变量，则其数值一旦在
        初始化之后便不能更改；
        2.如果是引用类型的变量，则在对其初始化之后，便不能再让其指向另一个对象
    2.作用于类
        1.这个类不能被继承，类中方法隐式的被指定为final
    3.作用于方法
        1.不能被继承修改
3.static关键字
    1.修饰成员变量、成员方法
        1.被修饰的变量属于这个类而不是单个某个对象，被类中所有对象共享，并可以
        通过类名调用，存放在方法区
    2.静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行
    (静态代码块—>非静态代码块—>构造方法)。 该类不管创建多少对象，
    静态代码块只执行一次.
      静态代码块在类被主动调用时执行 在类被初始化时执行
    3.静态内部类（static修饰类的话只能修饰内部类）：静态内部类与非
    静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会
    隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类
    却没有。没有这个引用就意味着：
        1. 它的创建是不需要依赖外围类的创建。
        2. 它不能使用任何外围类的非static成员变量和方法。
    4.调用顺序
    先初始化父类和子类的静态成员变量，之后在是按结构初始化父类（变量，构造函数）和子类（变量构造函数）。
4.equals == hashcode
    1.若某个类没有覆盖equals()方法，当它的通过equals()比较两个对象时，实际上
    是比较两个对象是不是同一个对象。这时，等价于通过“==”去比较这两个对象。
    2.我们可以覆盖类的equals()方法，来让equals()通过其它方式比较两个对象
    是否相等。通常的做法是：若两个对象的内容相等，则equals()方法返回true；否则，返回fasle。
    3.hashcode作用是获取哈希码 在有hashset的场景下，会判断加入的key对象是否已经
    被加入过。此时就需要重写key对象的hashcode方法和equals方法，来保证不会加入内容相同的对象
    [比如，重写一个person的的equals方法,让内容相同时视为相等，但这两个对象加入
    hashset时还是会都加进去，再重写了hashcode方法，也让内容相同时视为相等，此时加入
    第二个对象就会覆盖第一个对象]
5.object.clone 
    1.java赋值是复制对象引用，如果我们想要得到一个对象的副本，使用赋值操作是无法达到目的
    即修改p2也会影响到p1
    2.创建一个对象的新的副本，也就是说他们的初始状态完全一样，但以后可以改变各自的状态，
    而互不影响
    3.https://blog.csdn.net/u010947534/article/details/85050528
    clone的类中有引用对象时，这些引用类也需要实现cloneable接口
6. concurrentHashMap
    1.1.7 Segment 数组结构和 HashEntry 数组结构组成
        1.Segment 实现了 ReentrantLock,所以 Segment 是一种可重入锁，扮演锁的角色。
        HashEntry 用于存储键值对数据 即分段锁
    2. 1.8使用synchronized和CAS操作 
    synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍
    concurrentHashMap.computeIfAbsent 可以保证get和put的安全性
7. hashmap怎么put
    1.HashMap在put方法中，它使用hashCode()和equals()方法。当我们通过传递key-value对调用put方法的时候，
    HashMap使用Key hashCode()和哈希算法来找出存储key-value对的索引。如果索引处为空，则直接插入到对应的
    数组中，否则，判断是否是红黑树，若是，则红黑树插入，否则遍历链表，若长度超过8，则将链表转为红黑树，转成功之后 再插入。

8. 线程进程
    1.进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。
    2.线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程
    共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈，
9. 堆和方法区
    是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (所有对象都在这里分配内存)，
    方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
10.上下文切换
    概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，
    可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。
11.sleep和wait的区别 
    sleep没有释放锁 wait释放了锁 

12.反射
    JAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，
    都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 java 语言的反射机制。

13.泛型
    把类型明确的工作推迟到创建对象或调用方法的时候才去明确的特殊的类型
    https://segmentfault.com/a/1190000014120746

14.get和post
    1.GET请求的数据会附在URL之后，以?分割URL和传输数据，参数之间以&相连，
    2.POST把提交的数据则放置在是HTTP包的包体中。
    3. get请求用来从服务器上获得资源，而post是用来向服务器提交数据

15.session和cookie
    1.Cookie 一般用来保存用户信息 比如①我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以
    自动帮你登录的一些基本信息给填了；②一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，
    这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可
    (为了安全考虑，重新登录一般要将 Token 重写)；③登录一次网站后访问网站其他页面不需要重新登录。
    2.Session 的主要作用就是通过服务端记录用户的状态。 典型的场景是购物车，当你要添加商品到购物车的时候，系统
    不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户
    并且跟踪这个用户了。
    3.Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。