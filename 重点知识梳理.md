# 基础



## 拆箱装箱



    1.拆箱装箱



    2.装箱过程是通过调用包装器的valueOf方法实现的，而拆箱过程是通过调用包装器的 xxxValue方法实现的。



    3.通过valueOf方法创建Integer对象的时候，如果数值在[-128,127]之间，便返回指向IntegerCache.cache中已经存在的对象的引用；否则创建一个新的Integer对象。

        1.Integer n = new Integer(127) 不会使用缓存

        2.Integer n = 127 会出发缓存



    4.Integer i = new Integer(xxx) 不会触发装箱

      Integer i =xxx;              会触发装箱

    

    5. 包装类进行加减乘除时也会自动拆箱



## Java静态绑定与动态绑定



    1.https://blog.csdn.net/zhangjk1993/article/details/24066085



    2.如何理解 对象的类型在运行时才能确定？

    

        1. 需要使用者传入参数，才能确定调用哪个子类



        2. 根据反射来确定调用哪个类

    

    3.在程序执行前方法已经被绑定（也就是说在编译过程中就已经知道这个方法到底是哪个类中的方法）。

      java当中的方法只有final，static，private和构造方法是前期绑定

    

    4.在程序运行过程中，根据具体的实例对象才能具体确定是哪个方法。



        1.我们假设 Father ft=new Son(); ft.say(); Son继承自Father，重写了say()。

　         

        2.编译：我们知道，向上转型时，用父类引用执行子类对象，并可以用父类引用调用子类中重写了的同名方法。但是不能调用子类中新增的方法，为什么呢？

　　    因为在代码的编译阶段，编译器通过声明对象的类型（即引用本身的类型） 在方法区中该类型的方法表中查找匹配的方法（最佳匹配法：参数类型最接近的被调用），如果有则编      

        译通过。（这里是根据声明的对象类型来查找的，所以此处是查找 Father类的方法表，而Father类方法表中是没有子类新增的方法的，所以不能调用。）

　　    编译阶段是确保方法的存在性，保证程序能顺利、安全运行。

　

        3. 运行：我们又知道，ft.say()调用的是Son中的say()，这不就与上面说的，查找Father类的方法表的匹配方法矛盾了吗？不，这里就是动态绑定机制的真正体现。

        上面编译阶段在 声明对象类型 的方法表中查找方法，只是为了安全地通过编译（也为了检验方法是否是存在的）。而在实际运行这条语句时，在执行 Father ft=new Son(); 这一句时创建了一个Son实例对象，然后在 ft.say() 调用方法时，JVM会把刚才的son对象压入操作数栈，用它来进行调用。而用实例对象进行方法调用的过程就是动态绑定：根据实例对象所属的类型去查找它的方法表，找到匹配的方法进行调用

    

## 注解



    1.解析注解: 编译期扫描  运行期反射 



    2.注解：简化xml配置，注解的本质就是一个继承了 Annotation 接口的接口



    3.元注解：@Target作用目标  @Retention生命周期 @Inherited是否允许子类继承该注解 @Documented：注解是否应当被包含在 JavaDoc 文档中



## String



    1.

        String s1 = "hello";

        String s2 = "world";

        String s3 = "helloworld";

    

        System.out.println(s3 == s1 + s2);// false

        System.out.println(s3.equals((s1 + s2)));// true

        System.out.println(s3 == "hello" + "world");//false

        System.out.println(s3.equals("hello" + "world"));// true

        

        s1与s2相加是先在字符串常量池中开一个空间，然后拼接，这个空间的地址就是s1与s2拼接后的地址。与s3的地址不同，所以输出为false。



        s3与”hello”+”world”作比较，”hello”+”world”先拼接成”helloworld”,然后再去字符串常量池中找是否有”helloworld”,有，所以和s3共用一个字符串对象，则为true。

   

    2.String s = new String(“hello”)会创建2（1）个对象和1个引用，String s = “hello”创建1（0）个对象。 



## 枚举

    1. 把enum看成class 但是enum不能随便创建实例对象 只有它包含的几个对象



    2.public enum Weekday {

        MON(1,"mon"),TUS(2,"tus"),WED(3,"wed"),THU(4,"thu"),FRI(5,"fri"),SAT(6,"sat"),SUN(0,"sun");



        private int value;

        private String label;



        private Weekday(int value,String label){

            this.value = value;

            this.label = label;

        }

    }

    

    3.上面Weekday只能有MON...等7个变量 其构造方法也必须是private 因为不能在外面让别人实例对象出来



    还可以给每个枚举变量设置属性值 注意写法  要有相应的构造方法



    4. 单例 



    因为枚举类生成的对象个数由自己控制   下面表示只能生成一个singleton对象

    enum Singleton{

        singleton;

    }



-----------------------------------------------------------------------------------------------------------------------------------------------------------

# 容器



## CopyOnWrite技术



    1.Linux中的CopyOnWrite



        1.fork()会产生一个和父进程完全相同的子进程(除了pid)，按传统的做法，会直接将父进程的数据拷贝到子进程中，拷贝完之后，父进程和子进程之间的数据段和堆栈是相互独立的。

        而往往子进程都会执行exec()来做自己想要实现的功能，执行exec()，原有的数据会被清空。



        2.那干脆fork创建出的子进程，与父进程共享内存空间。也就是说，如果子进程不对内存空间进行写入操作的话，内存空间中的数据并不会复制给子进程，这样创建子进程的速度就很快了！(不用复制，直接引用父进程的物理空间)。



        4.换句话说，在fork之后exec之前两个进程用的是相同的物理空间（内存区），子进程的代码段、数据段、堆栈都是指向父进程的物理空间，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个。



        当父子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间。



            1.当行为不是exec()时，内核会给子进程的数据段、堆栈段分配相应的物理空间（至此两者有各自的进程空间，互不影响），而代码段继续共享父进程的物理空间（两者的代码完全相同）。



            2.行为是exec()时，由于两者执行的代码不同，子进程的代码段也会分配单独的物理空间。



        5.实现原理：fork()之后，kernel把父进程中所有的内存页的权限都设为read-only，然后子进程的地址空间指向父进程。当父子进程都只读内存时，相安无事。当其中某个进程写内存时，CPU硬件检测到内存页是read-only的，于是触发页异常中断（page-fault），陷入kernel的一个中断例程。中断例程中，kernel就会把触发的异常的页复制一份，于是父子进程各自持有独立的一份。



        6.好处： COW技术可减少分配和复制大量资源时带来的瞬间延时。  因为不用给子进程赋予新的进程空间

        COW技术可减少不必要的资源分配。比如fork进程时，并不是所有的页面都需要复制，父进程的代码段和只读数据段都不被允许修改，所以无需复制。

    

    2.文件系统中的Copy-on-write

        

        1.在对数据进行修改的时候，不会直接在原来的数据位置上进行操作，而是重新找个位置修改，这样的好处是一旦系统突然断电，重启之后不需要做Fsck。好处就是能保证数据的完整性，掉电的话容易恢复。

    

    3.Java中的CopyOnWriteList

        

        1.https://www.cnblogs.com/dolphin0520/p/3938914.html



        2.通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。



        写时加锁，只能一个线程写。读不加锁，可以多个线程读。



        3.适用领域：CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景，假如我们有一个搜索网站，用户在这个网站的搜索框中，输入关键字搜索内容，但是某些关键字不允许被搜索。这些不能被搜索的关键字会被放在一个黑名单当中，黑名单每天晚上更新一次。当用户搜索时，会检查当前关键字在不在黑名单当中，如果在，则提示不能搜索。



        4.使用注意：



            1. 减少扩容开销。根据实际需要，初始化CopyOnWriteMap的大小，避免写时CopyOnWriteMap扩容的开销。



　　        2. 使用批量添加。因为每次添加，容器每次都会进行复制，所以减少添加次数，可以减少容器的复制次数。如使用上面代码里的addBlackList方法。



        5.缺点：



            1.内存占用



            2.只能保证数据的最终一致性，不能保证实时一致性



## Fast-Fail机制



    1.当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件



    2.迭代器在调用next()、remove()方法时都是调用checkForComodification()方法，它检测modCount == expectedModCount ？ 若不等则抛出ConcurrentModificationException 异常，从而产生fail-fast机制



    3.场景：使用CopyOnWriteArrayList来替换ArrayList。



-----------------------------------------------------------------------------------------------------------------------------------------------------------

# JVM



## 方法逃逸



    1.方法内定义的变量 被传到方法外引用



    2.即原本分配再堆上的对象被分配在栈上




-----------------------------------------------------------------------------------------------------------------------------------------------------------



# Java多线程



## 上下文切换



    1：线程上下文切换指啥？与进程上下文切换的区别



    进程间的上下文切换因为是用户态和内核态之间的切换，需要消耗更多的资源，例如，寄存器中的内容切换出，缓存的刷新等，而线程间的上下文切换是用户态的线程切换，由于是同一个虚拟内存，消耗资源相对较少。



    线程上下文切换指一个线程被暂停剥夺对CPU的使用权，另外一个线程被选中开始或者继续在CPU中运行的过程。



    2：线程上文切换的问题？

    上下文切换会导致额外的性能开销，因为一个线程正在CPU上执行需要停下来换另外一个线程来执行，需要做许多的事情。



    3：上下文切换的性能开销花费在哪里啦？

    操作系统保存和恢复上下文；

    调度器进行线程调度；

    处理器高速缓存重新加载；

    上下文切换也可能导致整个高速缓存区被冲刷，从而带来时间开销。



    4：上下文切换的分类？

    上下文切换分为进程上下文切换和线程上下文切换，这是站在操作系统的层面来讲的，站在CPU的角度，它不知道什么进程、线程之类的东西，他只需要知道怎么取指令怎么执行就行啦！



    5：上下文切换的发送场景？

    上下文切换分为两种，一是自发上下文切换，另一个是非自己上下文切换。



    6：啥是自发上下文切换？怎么触发？

    自发性上下文切换指线程由 Java 程序调用导致切出，在多线程编程中，执行调用以下方法或关键字，常常就会引发自发性上下文切换。

    sleep()

    wait()

    yield()

    join()

    park()

    synchronized

    lock



    7：啥是非自发上下文切换？怎么触发？

    非自发性上下文切换指线程由于调度器的原因被迫切出。常见的有：线程被分配的时间片用完，虚拟机垃圾回收导致或者执行优先级的问题导致。



    8：在多线程中使用 Synchronized 会发生进程间的上下文切换，具体的发生环节如下



    当升级到重量级锁后，线程竞争锁资源，将会进入等待队列中，并在等待队列中不断尝试获取锁资源。每次去获取锁资源，都需要通过系统调底层操作系统申请获取Mutex Lock，这个过程就是一次用户态和内核态的切换。

   



## 锁的状态



    1.无锁->偏向锁->轻量级锁->重量级锁



    2.偏向锁  

        1.偏向锁是指一段同步代码一直被一个线程所访问，

        那么该线程会自动获取锁。降低获取锁的代价。

    

    3.轻量级锁 [自旋]



        1.轻量级锁是指当锁是偏向锁的时候，被另一个线程

        所访问，偏向锁就会升级为轻量级锁，其他线程会

        通过自旋的形式尝试获取锁，不会阻塞，提高性能。

    

    4.重量级锁

        1.重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，

        但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，

        就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线

        程进入阻塞，性能降低。

    

    5.理解自旋锁 https://zhuanlan.zhihu.com/p/40729293



        1.自旋状态下不会主动放弃CPU 自旋锁不会使线程状态发生切换，一直处于用户态，即线程一直都是active的；不会使线程进入阻塞状态，减少了不必要的上下文切换，执行速度快  但也会造成CPU使用率高  因为你自旋不会放弃CPU 一直在浪费时间。升级为syn是之后不会浪费时间，但是会引发上下文切换，性能降低。



        2.非自旋锁在获取不到锁的时候会进入阻塞状态，从而进入内核态，当获取到锁的时候需要从内核态恢复，需要进程上下文切换。 （线程被阻塞后便进入内核（Linux）调度状态，这个会导致系统在用户态与内核态之间来回切换，严重影响锁的性能）



        3.代码实现

        `````

        public class SpinLock {

            private AtomicReference<Thread> cas = new AtomicReference<Thread>();

            public void lock() {

                Thread current = Thread.currentThread();

                // 利用CAS

                while (!cas.compareAndSet(null, current)) {

                    // DO nothing

                }

            }

            public void unlock() {

                Thread current = Thread.currentThread();

                cas.compareAndSet(current, null);

            }

        }

        `````

        A线程进来时 执行lock() 此时cas.compareAndSet(null, current)的意思是 如果cas==null 就把cas赋值current 即A

        最开始cas肯定为null 所以成立

        B进来是，执行lock() 此时cas！=null 所以cas失败 会一直在循环处自旋




## synchronized 和 ReentrantLock 区别是什么



    1.synchronized是关键字、ReentrantLock是类



        1.ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，

        可以被继承、可以有方法、可以有各种各样的类变

    

    2.ReentrantLock可以对获取锁的等待时间进行设置



    3.ReentrantLock可以获取各种锁的信息



    4.sychronized是不可中断锁、非公平锁；ReentrantLock是可中断，可公平锁



        1.比如一个线程t1通过lockInterruptibly()方法获取到一个可重入锁，并执行一个长时间的任务，另一个线程通过interrupt()方法就可以立刻打断t1线程的执行，来获取t1持有的那个可重入锁。而通过ReentrantLock的lock()方法或者Synchronized持有锁的线程是不会响应其他线程的interrupt()方法的，直到该方法主动释放锁之后才会响应interrupt()方法



    5.ReentrantLock需在finally中手工释放锁



    6.ReentrantLock可以绑定多个条件




## synchronized 和 volatile 的区别是什么？



    1.volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，

    需要从主存中读取； 

    synchronized则是锁定当前变量，只有当前线程可以

    访问该变量，其他线程被阻塞住



    2.volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的



    3.volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞



    4.volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化




## 可重入锁和不可重入锁（自旋锁）



    1.可重入锁实现原理：当一个线程请求成功后，JVM会记下持有锁的线程，

    并将计数器计为1。此时其他线程请求该锁，则必须等待；

    而该持有锁的线程如果再次请求这个锁，就可以再次拿到这个锁，同时计数器会递增



## 高并发系统限流中的算法



    1.漏桶算法    [固定消耗，满了则不生产]



        1.一个固定容量的漏桶，按照固定常量速率流出请求，

        流入请求速率任意，当流入的请求数累积到漏桶容量时，

        则新流入的请求被拒绝



    2.令牌桶算法   [固定生产，满了则消耗]



        1.一个存放固定容量令牌的桶，按照固定速率往桶里添加令牌，

        填满了就丢弃令牌，请求是否被处理要看桶中令牌是否足够，

        当令牌数减为零时则拒绝新的请求



    3.计数器限流算法



        1.用来限制一定时间内的总并发数，

        比如数据库连接池、线程池、秒杀的并发数



-----------------------------------------------------------------------------------------------------------------------------------------------------------




# 数据库



## Mysql中引擎对比



    1.InnodDB  支持行锁 外键 事务



    2.MyISAM   支持表锁



## B树和B+树的区别



    1.B+跟B树不同B+树的非叶子节点不保存关键字记录的指针，只进行数据索引，这样使得B+树每个非叶子节点所能保存的关键字大大增加；



    2.B+树叶子节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取到。所以每次数据查询的次数都一样；



    3.B+树叶子节点的关键字从小到大有序排列，叶子节点之间有双向指针链接



    4.

        1、B+树的层级更少：相较于B树B+每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快；



            1.这里怎么理解呢？ 比如有15个节点 B树一个索引节点能容纳3个关键字  那么需要5个上层节点 B+树一个索引节点能容纳5个关键字 那么只需要



            3个上层节点。 于是它会更快的收敛到根节点。



        2、B+树查询速度更稳定：B+所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;



        3、B+树天然具备排序功能：B+树所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。



        4、B+树全节点遍历更快：B+树遍历整棵树只需要遍历所有的叶子节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。



    5. B树相对于B+树的优点是，如果经常访问的数据离根节点很近，而B树的非叶子节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比B+树快。



## 索引



    1.一种空间换时间的策略



    2. 操作系统一次读取一页到内存中， 如果用UUID做索引，UUID比主键ID长。那么一页中能装的数据会变少，会生成更多的页，B+树会变高。



## 索引优化



    (a,b,c,d,e) a为主键



    1.聚簇索引一般为主键索引 叶子节点包含数据的全部列信息



    2.建立辅助索引 即非聚簇索引 create tzx_bcd on tzx(b,c,d) 



        1.每创建一个索引会生成一颗b+树 



        2.叶节点排序 先比B 再比c 再比d



        3.非叶节点中key也是bcd

    

    3.为了减少空间占用，创建辅助索引时，叶子节点只会保存索引列(b,c,d)和主键 



    4. 最左前缀原则： 查询从索引最左前列开始且不跳过中间列



    5.Order by 优化 

        

        1.select * from  where b>2 order by b  index为(b,c) 



            1. where b>2 order by b 则走索引

            2. where b>2 order by c  =不走索引

            3. where c>2 ....        不走索引

        

        2.不走索引的话 都使用filesort



            1.双路排序

                1.2次IO 先把order by 的读入 排好了再取其他列

            2.单路排序

                1.1次IO 一次性把所有列读入内存排序  但数据太大 要分多次读入内存 



    6.问题分析

    

        1. select .. where a > 1    （索引为a的主键索引）



            1.先找到a=1的节点 然后返回它后面的叶子节点



            2.b c ..e 的范围查找不能走索引



        2. select *  where b>1   （索引为b c d）



            1.原则上走索引bcd 但时它查出来是某叶子节点的一段范围，而且叶子节点只保存了索引列，要查询所有列还需要回到聚簇索引中再查找一次



            不如直接走全表扫描

            

            2. 所以mysql会优化为直接走全表扫描



        3. select b,c,d  where b>1   （索引为b c d）



            1.查询字段不需要回表时，可走索引  因为此时索引覆盖了查询字段



            2.称作 覆盖索引

        

        4. select b,c,d from tzx  （索引为b c d）



            1.没有where 也走索引



            2.因为覆盖索引中叶节点中数据比聚簇索引少，所以每一页放入的叶节点就多，所需要的页数就少，所以走索引快



            3.直接从覆盖索引的第一个叶节点开始查找 

    

        5. 最左前缀 select * where c = 1 and d = 1  （索引为b c d）

                            where b = 1 and d = 1 

            1. 上面不走索引 因为不能比大小



            2.下面可走索引 不过只用了b=1一个字段  先用b=1走索引 找到叶节点 再用d=1过滤 再回表拿数据

       

        6. 范围之后 索引失效 因为要回表    

            

            select * where a=1 and b > 1 and c = 2 

            使用到a b 索引 不使用c 

        

        7. 一些失效原则

            3.不在索引列上做任何操作（计算、函数（自动or手动）类型转换），会导致索引失效而转向全表扫描。

                1.如 select ..where a+1 = 1  不走a索引

                2.因为需要把树中所有节点都+1 浪费时间

            4.存储引擎不能使用索引中范围右列的列，范围之后索引全失效。

            5.尽量使用覆盖索引(只访问索引的查询（索引列和查询一致)),减少select *。

            6.mysql在使用不等于(!=或者<>)的时候无法使用索引会导致全表扫描。

            7.is null,is not null也无法使用索引，所以表中的数据应该不能为NULL。

            8.like以通配符开头('%abc...')或者('%abc%...')，mysql索引失效会变成全表扫描的操作，使用('abc%')索引不失效。

                1.覆盖索引"%ac% 会索引生效

            9.查找字符串不加单引号索引失效。

                1.数据库会把字符都转为数字

                2.若走索引 需要把树中所有的字符串转为为数字

            10.少用or,用它来连接时会索引失效。




## 慢查询优化



    1.MySQL慢查询就是在日志中记录运行比较慢的SQL语句



        1.long_query_time = 10

        log-slow-queries = /var/lib/mysql/mysql-slow.log



        2.超过10s的查询会被日志记录在mysql-slow.log

    

    2. 使用explain语句分析上述语句



        1.ID

            表示SQL执行的顺序 越大优先级越高

        2.select_type 

            表示查询中每个select子句的类型  有没有使用union之类的

        3.table

            表

        4.type   在表中找到所需行的方式  “访问类型”

            ALL：Full Table Scan， MySQL将遍历全表以找到匹配的行



            index: Full Index Scan，index与ALL区别为index类型只遍历索引树



            range:只检索给定范围的行，使用一个索引来选择行  如where a > 1



            ref: 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值



            eq_ref: 类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件



            const、system: 当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量,system是const类型的特例，当查询的表只有一行的情况下，使用system



            NULL: MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。

       

        5.possible_keys

            指出MySQL能使用哪个索引在表中找到记录，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用



        6.Key

            key列显示MySQL实际决定使用的键（索引）

        7.key_len

            索引中使用的字节数

        8.ref

            表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值

        9.rows

            表示MySQL根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数

        10.Extra

            该列包含MySQL解决查询的详细信息,

            using index 表示使用索引 并且没有回表

            using where 条件查询

            Using filesort : groupBy orderby 时 索引失效

            Using temporary：表示为了得到结果，使用了临时表，这通常是出现在多表联合查询，结果排序的场合



## 一条sql语句是如何执行



    1.https://blog.csdn.net/Megustas_JJC/article/details/84380108



    2.MYSQL分为SERVER层和存储引擎层两部分



    3.server层

        1.连接器

            负责跟客户端连接  权限验证

        2.查询缓存

            之前若查询过会生成缓存 只适合长时间不更新的表 因为更新表后会清空缓存

        3.分析器

            1.词法分析  识别关键字

            2.语法分析  判断是否满足语法

        3.优化器

            有多个索引时决定用哪个索引

            多表关联时决定连接顺序

        4.执行器

            先判断有没有该表的查询权限 有则使用对应引擎提供的接口

            调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中；

            调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。

            执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。



    4.存储引擎层

        1.负责数据的存储和提取 支持多个存储引擎



##  数据库的锁



    1.全局锁 一般用于备份



    2.表锁 

        1.偏读 MYISAM   lock table mylock READ ,book WRITE

        2.会话1给表加读锁 未解锁之前 不能读别人 不能写自己

          会话2可以读该表 写该表会阻塞 等到会话1解锁之后立即执行

        

        3. 会话1给表加写锁 可以读自己 写自己 不能读写别人

           会话2读写该表都会阻塞

    

        4.MYISAM查询时自动加读锁  增删改时加表锁  所以写多时  会大量阻塞

    

    3. 行锁



        1.偏写 偏INNODB 支持事务



        2.关闭自动提交 且未提交时，可以读到己之所写  会话2读不到会话1的写

        

        3.在对一行更新且没提交时，另一会话对该行的更新会阻塞



        4.索引失效 会使行锁变为表锁



        5.间隙锁

            1.用范围条件检索数据时，会把该范围内所有行都加锁，即使数据库中没有某一行。那么另一会话添加该行时也会阻塞。

        

        6. 锁某一行

           select * from tzx where a = 8 for update  //上锁



## MVCC  多版本控制



    1.聚簇索引中有两个隐藏列 trx_id 是事务id roll_pointer 指向该记录上一个版本的位置



## 事务和隔离级别

    1. 事务的四大特征：

        1. 原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败。

            1.在同一个事务内部的一组操作必须全部执行成功（或者全部失败）。

                为了保证事务操作的原子性，必须实现基于日志的REDO/UNDO机制：将所有对数据的更新操作都写入日志，如果一个事务中的一部分操作已经成功，但以后的操作，由于断电/系统崩溃/其它的软硬件错误而无法继续，则通过回溯日志，将已经执行成功的操作撤销，从而达到“全部操作失败”的目的。 最常见的场景是，数据库系统崩溃后重启，此时数据库处于不一致的状态，必须先执行一个crash recovery的过程：读取日志进行REDO（重演将所有已经执行成功但尚未写入到磁盘的操作，保证持久性），再对所有到崩溃时尚未成功提交的事务进行UNDO（撤销所有执行了一部分但尚未提交的操作，保证原子性）。crash recovery结束后，数据库恢复到一致性状态，可以继续被使用。

            2.必须在同一个事务内部调用对帐户A和帐户B的操作，才能保证数据的一致性

        2. 持久性：当事务提交或回滚后，数据库会持久化的保存数据。


        3. 隔离性：多个事务之间。相互独立。

        4. 一致性：事务操作前后，数据总量不变   
            
            1.事务的原子性只能保持单线程的一致性  不能保证多线程的一致性

            2.事务1需要将100元转入帐号A：先读取帐号A的值，然后在这个值上加上100。但是，在这两个操作之间，另一个事务2修改了帐号A的值，为它增加了100元。那么最后的结果应该是A增加了200元。但事实上，事务1最终完成后，帐号A只增加了100元，因为事务2的修改结果被事务1覆盖掉了。

            AB两用户相互转账，不管操作几次，钱总额不会变



    2. 事务的隔离级别（了解）  

        * 概念：多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。

        * 存在问题：

            1. 脏读：一个事务，读取到另一个事务中[没有提交]的数据

            2. 不可重复读(虚读)：[读到已提交的数据]在同一个事务中，两次读取到的数据不一样。

            3. 幻读：一个事务操作(DML)数据表中所有记录，另一个事务添加(并没有修改)了一条数据，则第一个事务查询不到自己的修改。

        在数据库增删改查四种操作中，insert、delete和update都是会加排它锁(Exclusive Locks)的，而select只有显式声明才会加锁:

        select: 即最常用的查询，是不加任何锁的
        select ... lock in share mode: 会加共享锁(Shared Locks)
        select ... for update: 会加排它锁

        * 隔离级别：

            1. read uncommitted：读未提交   纯粹读的时候可以使用一下

                * 产生的问题：脏读、不可重复读、幻读

                1. 底层实现 
                    1.读不加锁
                    2.写加锁  
                    3.事务A加写锁 让事务B不能加读锁 但是事务B可以使用不加读锁的读来读该行 所以B能读到A未提交的修改
            

        
            2. read committed：读已提交 （Oracle） 事务无法看见其他未提交事务的修改

                * 产生的问题：不可重复读、幻读
                1，写数据加写锁 读数据不加锁 使用MVCC多版本并发控制  聚簇索引中加了两个隐藏列 [版本号，指针]

                *** 事务在进行读操作时，使用的是事务开始时的行快照数据，这样就不用担心读到其他其他事务修改的数据。

                2. MVCC实现  

                    1.创建一个readview列表 记录已开始但没提交的事务ID 开启事务30 其指针指向20。
                    2.此时B事务去查，readview中增加30，事务30还未提交，所以B查到的是20。
                    3.然后提交30 新建40，此时 readview 把30去掉，新增40，B再查，查到的就是30. 即读到了已提交的数据

                    4.在RR级别中， 30提交后，列表中不会去掉30，所以B查到的还是30之前的20.  即可以重复读

            3. repeatable read：可重复读 （MySQL默认） 只读事务开始时的快照数据 

                * 产生的问题：幻读

                1. MVCC只能控制读操作 即select  当进行update等操作时，不是去读快照，而是去读真实的数据

                2.所以 例如 A事务 select count(name) where name = tzx 第一次读是0 然后B事务添加了10条name=tzx的数据 第二次读就是10了

                3.解决幻读 
                    1.使用gap锁 锁住要查询的那个范围的所有行 让别的事务不能新增
                    2.转为串行化 读写都加锁  select 也加锁 share in mode 直到事务结束才释放锁 A没执行完的时候 不让B执行

                4.mvcc是乐观锁机制  如果使用悲观锁的机制  读的时候加读锁 直到事务结束才释放 也可以防止B事务对他的修改 

            4. serializable：串行化  事务串行化顺序执行  加表锁？
 

            * 注意：隔离级别从小到大安全性越来越高，但是效率越来越低

            * 数据库查询隔离级别：

                * select @@tx_isolation;

            * 数据库设置隔离级别：

                * set global transaction isolation level  级别字符串;



        * 演示：

            set global transaction isolation level read uncommitted;

            start transaction;

            -- 转账操作

            update account set balance = balance - 500 where id = 1;

            update account set balance = balance + 500 where id = 2;

## 事务的传播机制

    1.propagation_requierd 如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事务中，这是最常见的选择。
        methodA() {
             methodB();
        }
        methodB();

        A B的属性都为requierd 在调用methodB时，没有一个存在的事务，所以获得一个新的连接，开启了一个新的事务 
        调用MethodA时，环境中没有事务，所以开启一个新的事务.当在MethodA中调用MethodB时，环境中已经有了一个事务，所以methodB就加入当前事务。
    
    2.PROPAGATION_SUPPORTS  如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行。

        //事务属性 PROPAGATION_REQUIRED 
        methodA(){ 
        methodB(); 
        }
        
        //事务属性 PROPAGATION_SUPPORTS 
        methodB(){ 
        …… 
        }

        单独调用B时 此时不会创建新事务 所以是非事务的执行。 而调用A时，B会加入A的事务
    
    3.PROPAGATION_REQUIRES_NEW   总是开启一个新的事务。如果一个事务已经存在，则将这个存在的事务挂起。
        //事务属性 PROPAGATION_REQUIRED 
        methodA(){ 
        doSomeThingA(); 
        methodB(); 
        doSomeThingB(); 
        }
        
        //事务属性 PROPAGATION_REQUIRES_NEW 
        methodB(){ 
        …… 
        }


        此时A调用B的话 先挂起A的事务 再开启B的新事物 当B事务结束后， A的方法出了问题回滚，不会让B的方法回滚。
    
##  乐观锁和悲观锁  ！！ [和读锁写锁不是同一个东西]    解决并发控制

    1. 悲观锁

        1.独占和排他性  认为数据被并发修改的概率很大

        2. 又分别共享锁和排他锁 即读锁和写锁

            1.A事务加了读锁  B事务只能加读锁 不能加写锁    即只能读不能写

            2.A事务加了写锁  B事务不能读也不能写        

            3. 实现

                1.关闭mysql自动提交 for update 进行加锁  

                2.行锁都是基于索引 所以该SQL语句如果用不到索引的话 会变成表锁  

    2. 乐观锁

        1. 假设数据不会被修改 所以只有更新数据的时候 才会对数据的冲突进行检测

        2. CAS实现

            1.解决ABA问题 那么给数据设置一个递增的version字段  或者时间戳
        
    3， 加表锁  lock table tzx1 READ,tzx2 WRITE

    



## 分库分表

    1.垂直分库  根据业务分库 如订单表 支付表 商品表

    2.垂直分表  按字段分成多个表。 比如把经常访问的列分成一个单独的表

    3.水平分库  如订单1库 订单2库 订单3库  通过hash算法来决定分在哪个库
    
    4.水平分表 单表数据量还是很大的时候，按日或者按月分表

    5. 主键ID会失效  那么引进全局ID