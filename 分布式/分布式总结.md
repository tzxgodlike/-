https://github.com/Snailclimb/JavaGuide/blob/master/docs/system-design/website-architecture/%E5%88%86%E5%B8%83%E5%BC%8F.md

经典基础理论
https://blog.csdn.net/qq_34337272/article/details/80444032

## 分布式系统设计思路

    1.中心化
        1.“领导” “职工”
        2.两个领导
    
    2.去中心化
        1.节点地位平等，自由选择中心
        2.“脑裂”问题 
        一个集群由于网络故障，分裂为两个无法相互通信的集群

    3.
        1.分布式 一个业务拆分为多个子业务
        2.集群 同一个业务 部署在多个服务器上

## CAP定理
    https://www.cnblogs.com/hxsyl/p/4381980.html
    1.概念
        一致性（Consistence） :所有节点访问同一份最新的数据副本
        可用性（Availability）:每次请求都能获取到非错的响应——但是不保证获取的数据为最新数据
        分区容错性（Partition tolerance） : 分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。

    2.P必须实现 在C A之间权衡

    3.证明
        CAP的证明很简单，假设两个节点集{G1, G2}，由于网络分片导致G1和G2之间所有的通讯都断开了，
        如果在G1中写，在G2中读刚写的数据， G2中返回的值不可能G1中的写值。由于A的要求，G2一定要返回这次读请求，
        由于P的存在，导致C一定是不可满足的。

## BASE理论
    1.BASE 是 Basically Available（基本可用） 、Soft-state（软状态） 和 Eventually Consistent（最终一致性） 三个短语的缩写。
    BASE理论是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于CAP定理逐步演化而来的，它大大降低了我们对系统的要求。

    2. B  基本可用 
    基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。但是，这绝不等价于系统不可用。
    比如：
    响应时间上的损失:正常情况下，一个在线搜索引擎需要在0.5秒之内返回给用户相应的查询结果，但由于出现故障，查询结果的响应时间增加了1~2秒
    系统功能上的损失：正常情况下，在一个电子商务网站上进行购物的时候，消费者几乎能够顺利完成每一笔订单，但是在一些节日大促购物高峰的时候，由于消费者的购物行为激增，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面

    3.软状态
    软状态指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时

    4.最终一致性
    最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。


## 分布式事务

    1.概念
    就是一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，
    分布式事务需要保证这些小操作要么全部成功，要么全部失败。本质上来说，分布式事务就是为了保证不同数据库的数据一致性。

    2.产生原因
        1.数据库的分库分表
        2.业务服务化  如电商网站拆解为订单中心 数据库中心等 
    
    3.特性ACID

    4.应用场景：
        1.支付
        而对于买家账户属于买家中心，对应的是买家数据库，而卖家账户属于卖家中心，对应的是卖家数据库，对不同数据库的操作必然需要引入分布式事务。
        2.在线下单
        买家在电商平台下单，往往会涉及到两个动作，一个是扣库存，第二个是更新订单状态，库存和订单一般属于不同的数据库，需要使用分布式事务保证数据一致性。
    
    5.解决方案
        1.基于XA协议的两阶段提交
        https://www.jianshu.com/p/37f92dc60101
            1.我们的应用程序（client）发起一个开始请求到TC；
            2.TC先将<prepare>消息写到本地日志，之后向所有的Si发起<prepare>消息。以支付宝转账到余额宝为例，TC给A的prepare消息是通知支付宝数据库相应账目扣款1万，TC给B的prepare消息是通知余额宝数据库相应账目增加1w。为什么在执行任务前需要先写本地日志，主要是为了故障后恢复用，本地日志起到现实生活中凭证 的效果，如果没有本地日志（凭证），出问题容易死无对证；
            3.Si收到<prepare>消息后，执行具体本机事务，但不会进行commit，如果成功返回<yes>，不成功返回<no>。同理，返回前都应把要返回的消息写到日志里，当作凭证。
            4.TC收集所有执行器返回的消息，如果所有执行器都返回yes，那么给所有执行器发生送commit消息，执行器收到commit后执行本地事务的commit操作；如果有任一个执行器返回no，那么给所有执行器发送abort消息，执行器收到abort消息后执行事务abort操作。

            5.通信时间太长 性能太差 不适合高并发
        
        2.消息事务+最终一致性
            1、A系统向消息中间件发送一条预备消息
            2、消息中间件保存预备消息并返回成功
            3、A执行本地事务
            4、A发送提交消息给消息中间件

            通过以上4步完成了一个消息事务。对于以上的4个步骤，每个步骤都可能产生错误，下面一一分析：

            步骤一出错，则整个事务失败，不会执行A的本地操作
            步骤二出错，则整个事务失败，不会执行A的本地操作
            步骤三出错，这时候需要回滚预备消息，怎么回滚？答案是A系统实现一个消息中间件的回调接口，消息中间件会去不断执行回调接口，检查A事务执行是否执行成功，如果失败则回滚预备消息
            步骤四出错，这时候A的本地事务是成功的，那么消息中间件要回滚A吗？答案是不需要，其实通过回调接口，消息中间件能够检查到A执行成功了，这时候其实不需要A发提交消息了，消息中间件可以自己对消息进行提交，从而完成整个消息事务
            基于消息中间件的两阶段提交往往用在高并发场景下，将一个分布式事务拆成一个消息事务（A系统的本地操作+发消息）+B系统的本地操作，其中B系统的操作由消息驱动，只要消息事务成功，那么A操作一定成功，消息也一定发出来了，这时候B会收到消息去执行本地操作，如果本地操作失败，消息会重投，直到B操作成功，这样就变相地实现了A与B的分布式事务。
    
    6.https://www.jianshu.com/p/1156151e20c8
    一致性概述

## 一致性算法

    